# Adapted from XSteam Visual Basic Package from Magnus Holgrem
# See LICENSE for copyright information

import math

import numpy as np
from numba import jit, float64, int64

__R = 0.461526  # kJ/(kg K)
__MOLAR_MASS = 18.015257
__CRITICAL_TEMPERATURE = 647.096  # K
__CRITICAL_PRESSURE = 22.064  # MPa


# ***********************************************************************************************************
# *2 IAPWS IF 97 Calling functions                                                                          *
# ***********************************************************************************************************
#
# ***********************************************************************************************************
# *2.1 Functions for region 1
@jit(float64(float64, float64), cache=True, nopython=True)
def v1_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation
    # Equation 7, Table 3, Page 6
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8,
                   21, 23, 29, 30, 31, 32])
    j1 = np.array([-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10,
                   -8, -11, -6, -29, -31, -38, -39, -40, -41])
    n1 = np.array(
        [0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872, 0.15772038513228,
         -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04, -0.018990068218419,
         -0.032529748770505, -0.021841717175414, -5.283835796993E-05, -4.7184321073267E-04, -3.0001780793026E-04,
         4.7661393906987E-05, -4.4141845330846E-06, -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06,
         -8.5205128120103E-10, -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
         -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20, 2.6335781662795E-23,
         -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26])
    # kJ/(kg K)
    pi = p / 16.53
    tau = 1386 / t
    gamma_der_pi = 0
    for i in range(0, 34):
        gamma_der_pi -= n1[i] * i1[i] * (7.1 - pi) ** (i1[i] - 1) * (tau - 1.222) ** j1[i]

    return __R * t / p * pi * gamma_der_pi / 1000


@jit(float64(float64, float64), cache=True, nopython=True)
def h1_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation
    # Equation 7, Table 3, Page 6
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5,
                   8, 8, 21, 23, 29, 30, 31, 32])
    j1 = np.array([-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5,
                   -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41])
    n1 = np.array([0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
                   0.15772038513228, -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04,
                   -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993E-05,
                   -4.7184321073267E-04, -3.0001780793026E-04, 4.7661393906987E-05, -4.4141845330846E-06,
                   -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06, -8.5205128120103E-10,
                   -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
                   -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20,
                   2.6335781662795E-23, -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26])
    # kJ/(kg K)
    pi = p / 16.53
    tau = 1386 / t
    gamma_der_tau = 0
    for i in range(0, 34):
        gamma_der_tau += n1[i] * (7.1 - pi) ** i1[i] * j1[i] * (tau - 1.222) ** (j1[i] - 1)

    return __R * t * tau * gamma_der_tau


@jit(float64(float64, float64), cache=True, nopython=True)
def u1_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation
    # Equation 7, Table 3, Page 6
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5,
                   8, 8, 21, 23, 29, 30, 31, 32])
    j1 = np.array([-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5,
                   -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41])
    n1 = np.array([0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
                   0.15772038513228, -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04,
                   -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993E-05,
                   -4.7184321073267E-04, -3.0001780793026E-04, 4.7661393906987E-05, -4.4141845330846E-06,
                   -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06, -8.5205128120103E-10,
                   -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
                   -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20,
                   2.6335781662795E-23, -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26])
    # kJ/(kg K)
    pi = p / 16.53
    tau = 1386 / t
    gamma_der_tau = 0
    gamma_der_pi = 0
    for i in range(0, 34):
        gamma_der_pi -= n1[i] * i1[i] * (7.1 - pi) ** (i1[i] - 1) * (tau - 1.222) ** j1[i]
        gamma_der_tau += n1[i] * (7.1 - pi) ** i1[i] * j1[i] * (tau - 1.222) ** (j1[i] - 1)

    return __R * t * (tau * gamma_der_tau - pi * gamma_der_pi)


@jit(float64(float64, float64), cache=True, nopython=True)
def s1_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation
    # Equation 7, Table 3, Page 6
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4,
                   5, 8, 8, 21, 23, 29, 30, 31, 32])
    j1 = np.array([-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5,
                   -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41])
    n1 = np.array([0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
                   0.15772038513228, -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04,
                   -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993E-05,
                   -4.7184321073267E-04, -3.0001780793026E-04, 4.7661393906987E-05, -4.4141845330846E-06,
                   -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06,
                   -8.5205128120103E-10, -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13,
                   -4.0516996860117E-07, -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19,
                   1.4478307828521E-20, 2.6335781662795E-23, -1.1947622640071E-23, 1.8228094581404E-24,
                   -9.3537087292458E-26])
    # kJ/(kg K)
    pi = p / 16.53
    tau = 1386 / t
    gamma = 0
    gamma_der_tau = 0
    for i in range(0, 34):
        gamma_der_tau += n1[i] * (7.1 - pi) ** i1[i] * j1[i] * (tau - 1.222) ** (j1[i] - 1)
        gamma += n1[i] * (7.1 - pi) ** i1[i] * (tau - 1.222) ** j1[i]

    return __R * tau * gamma_der_tau - __R * gamma


@jit(float64(float64, float64), cache=True, nopython=True)
def cp1_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation
    # Equation 7, Table 3, Page 6
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5,
                   8, 8, 21, 23, 29, 30, 31, 32])
    j1 = np.array([-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5,
                   -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41])
    n1 = np.array([0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
                   0.15772038513228, -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04,
                   -6.0706301565874E-04, -0.018990068218419, -0.032529748770505, -0.021841717175414,
                   -5.283835796993E-05, -4.7184321073267E-04, -3.0001780793026E-04, 4.7661393906987E-05,
                   -4.4141845330846E-06, -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06,
                   -8.5205128120103E-10, -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13,
                   -4.0516996860117E-07, -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19,
                   1.4478307828521E-20, 2.6335781662795E-23, -1.1947622640071E-23, 1.8228094581404E-24,
                   -9.3537087292458E-26])
    # kJ/(kg K)
    pi = p / 16.53
    tau = 1386 / t
    gamma_der_tautau = 0
    for i in range(0, 34):
        gamma_der_tautau += n1[i] * (7.1 - pi) ** i1[i] * j1[i] * (j1[i] - 1) * (tau - 1.222) ** (j1[i] - 2)

    return -__R * tau ** 2 * gamma_der_tautau


@jit(float64(float64, float64), cache=True, nopython=True)
def cv1_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation
    # Equation 7, Table 3, Page 6
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4,
                   5, 8, 8, 21, 23, 29, 30, 31, 32])
    j1 = np.array([-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17,
                   -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41])
    n1 = np.array([0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
                   0.15772038513228, -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04,
                   -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993E-05,
                   -4.7184321073267E-04, -3.0001780793026E-04, 4.7661393906987E-05, -4.4141845330846E-06,
                   -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06, -8.5205128120103E-10,
                   -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
                   -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20,
                   2.6335781662795E-23, -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26])
    # kJ/(kg K)
    pi = p / 16.53
    tau = 1386 / t
    gamma_der_pi = 0
    gamma_der_pipi = 0
    gamma_der_pitau = 0
    gamma_der_tautau = 0
    for i in range(0, 34):
        gamma_der_pi -= n1[i] * i1[i] * (7.1 - pi) ** (i1[i] - 1) * (tau - 1.222) ** j1[i]
        gamma_der_pipi += n1[i] * i1[i] * (i1[i] - 1) * (7.1 - pi) ** (i1[i] - 2) * (tau - 1.222) ** j1[i]
        gamma_der_pitau -= n1[i] * i1[i] * (7.1 - pi) ** (i1[i] - 1) * j1[i] * (tau - 1.222) ** (j1[i] - 1)
        gamma_der_tautau += n1[i] * (7.1 - pi) ** i1[i] * j1[i] * (j1[i] - 1) * (tau - 1.222) ** (j1[i] - 2)

    return __R * (-tau ** 2 * gamma_der_tautau + (gamma_der_pi - tau * gamma_der_pitau) ** 2 / gamma_der_pipi)


@jit(float64(float64, float64), cache=True, nopython=True)
def w1_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation
    # Equation 7, Table 3, Page 6
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3,
                   4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32])
    j1 = np.array([-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17,
                   -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41])
    n1 = np.array([0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
                   0.15772038513228, -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04,
                   -0.018990068218419, -0.032529748770505, -0.021841717175414, -5.283835796993E-05,
                   -4.7184321073267E-04, -3.0001780793026E-04, 4.7661393906987E-05, -4.4141845330846E-06,
                   -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06, -8.5205128120103E-10,
                   -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
                   -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20,
                   2.6335781662795E-23, -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26])
    # kJ/(kg K)
    pi = p / 16.53
    tau = 1386 / t
    gamma_der_pi = 0
    gamma_der_pipi = 0
    gamma_der_pitau = 0
    gamma_der_tautau = 0
    for i in range(0, 34):
        gamma_der_pi -= n1[i] * i1[i] * (7.1 - pi) ** (i1[i] - 1) * (tau - 1.222) ** j1[i]
        gamma_der_pipi += n1[i] * i1[i] * (i1[i] - 1) * (7.1 - pi) ** (i1[i] - 2) * (tau - 1.222) ** j1[i]
        gamma_der_pitau -= n1[i] * i1[i] * (7.1 - pi) ** (i1[i] - 1) * j1[i] * (tau - 1.222) ** (j1[i] - 1)
        gamma_der_tautau += n1[i] * (7.1 - pi) ** i1[i] * j1[i] * (j1[i] - 1) * (tau - 1.222) ** (j1[i] - 2)

    return (1000 * __R * t * gamma_der_pi ** 2 / (
        (gamma_der_pi - tau * gamma_der_pitau) ** 2 / (tau ** 2 * gamma_der_tautau) - gamma_der_pipi)) ** 0.5


@jit(float64(float64, float64), cache=True, nopython=True)
def t1_ph(p, h):
    # Release on the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation, 5.2.1 The Backward Equation T ( p,h )
    # Equation 11, Table 6, Page 10
    i1 = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 3, 4, 5, 6])
    j1 = np.array([0, 1, 2, 6, 22, 32, 0, 1, 2, 3, 4, 10, 32, 10, 32, 10, 32, 32, 32, 32])
    n1 = np.array([-238.72489924521, 404.21188637945, 113.49746881718, -5.8457616048039,
                   -1.528548241314E-04, -1.0866707695377E-06, -13.391744872602, 43.211039183559,
                   -54.010067170506, 30.535892203916, -6.5964749423638, 9.3965400878363E-03, 1.157364750534E-07,
                   -2.5858641282073E-05, -4.0644363084799E-09, 6.6456186191635E-08, 8.0670734103027E-11,
                   -9.3477771213947E-13, 5.8265442020601E-15, -1.5020185953503E-17])
    pi = p / 1
    eta = h / 2500
    t = 0
    for i in range(0, 20):
        t += n1[i] * pi ** i1[i] * (eta + 1) ** j1[i]

    return t


@jit(float64(float64, float64), cache=True, nopython=True)
def t1_ps(p, s):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 5 Equations for region 1, Section. 5.1 Basic Equation, 5.2.2 The Backward Equation T ( p, s )
    # Equation 13, Table 8, Page 11
    i1 = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 4])
    j1 = np.array([0, 1, 2, 3, 11, 31, 0, 1, 2, 3, 12, 31, 0, 1, 2, 9, 31, 10, 32, 32])
    n1 = np.array([174.78268058307, 34.806930892873, 6.5292584978455, 0.33039981775489,
                   -1.9281382923196E-07, -2.4909197244573E-23, -0.26107636489332, 0.22592965981586,
                   -0.064256463395226, 7.8876289270526E-03, 3.5672110607366E-10, 1.7332496994895E-24,
                   5.6608900654837E-04, -3.2635483139717E-04, 4.4778286690632E-05, -5.1322156908507E-10,
                   -4.2522657042207E-26, 2.6400441360689E-13, 7.8124600459723E-29, -3.0732199903668E-31])
    pi = p / 1
    sigma = s / 1
    t = 0
    for i in range(0, 20):
        t += n1[i] * pi ** i1[i] * (sigma + 2) ** j1[i]

    return t


@jit(float64(float64, float64), cache=True, nopython=True)
def p1_hs(h, s):
    # Supplementary Release on Backward Equations for
    # Pressure as a Function of Enthalpy and Entropy p(h,s) to the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam
    # 5 Backward Equation p(h,s) for region 1
    # Equation 1, Table 2, Page 5
    i1 = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 4, 4, 5])
    j1 = np.array([0, 1, 2, 4, 5, 6, 8, 14, 0, 1, 4, 6, 0, 1, 10, 4, 1, 4, 0])
    n1 = np.array([-0.691997014660582, -18.361254878756, -9.28332409297335,
                   65.9639569909906, -16.2060388912024, 450.620017338667, 854.68067822417,
                   6075.23214001162, 32.6487682621856, -26.9408844582931, -319.9478483343,
                   -928.35430704332, 30.3634537455249, -65.0540422444146, -4309.9131651613,
                   -747.512324096068, 730.000345529245, 1142.84032569021, -436.407041874559])
    eta = h / 3400
    sigma = s / 7.6
    p = 0
    for i in range(0, 19):
        p += n1[i] * (eta + 0.05) ** i1[i] * (sigma + 0.05) ** j1[i]

    return p * 100


@jit(float64(float64), cache=True, nopython=True)
def t4_p(p):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Section 8.2 The Saturation-Temperature Equation
    # Eq 31, Page 34
    beta = p ** 0.25
    e = beta ** 2 - 17.073846940092 * beta + 14.91510861353
    f = 1167.0521452767 * beta ** 2 + 12020.82470247 * beta - 4823.2657361591
    g = -724213.16703206 * beta ** 2 - 3232555.0322333 * beta + 405113.40542057
    d = 2 * g / (-f - (f ** 2 - 4 * e * g) ** 0.5)
    return (650.17534844798 + d - ((650.17534844798 + d) ** 2 - 4 * (-0.23855557567849 + 650.17534844798 * d)) ** 0.5) / 2


@jit(float64(float64, float64), cache=True, nopython=True)
def t1_prho(p, rho):
    # Solve by iteration. Observe that for low temperatures this equation has 2 solutions.
    # Solve with half interval method
    low_bound = 273.15
    high_bound = t4_p(p)
    rhos = -1000
    ts = 0
    while abs(rho - rhos) > 0.00001:
        ts = (low_bound + high_bound) / 2
        rhos = 1 / v1_pt(p, ts)
        if rhos < rho:
            high_bound = ts
        else:
            low_bound = ts

    return ts


# ***********************************************************************************************************
# *2.2 functions for region 2

@jit(float64(float64, float64), cache=True, nopython=True)
def v2_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2, Section. 6.1 Basic Equation
    # Table 11 and 12, Page 14 and 15
    # J0 = [0, 1, -5, -4, -3, -2, -1, 2, 3]
    # n0 = [-9.6927686500217, 10.086655968018, -0.005608791128302,
    #  0.071452738081455, -0.40710498223928, 1.4240819171444,
    #      -4.383951131945, -0.28408632460772, 0.021268463753307]
    ir = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5,
                   6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24])
    jr = np.array([0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16,
                   35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58])
    nr = np.array([-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, -0.057581259083432,
                   -0.05032527872793, -3.3032641670203E-05, -1.8948987516315E-04, -3.9392777243355E-03,
                   -0.043797295650573, -2.6674547914087E-05, 2.0481737692309E-08, 4.3870667284435E-07,
                   -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649, -7.8847309559367E-10,
                   1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06, -1.6714766451061E-11,
                   -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06,
                   -0.038946842435739, 1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08,
                   1.0406965210174E-19, -1.0234747095929E-13, -1.0018179379511E-09, -8.0882908646985E-11,
                   0.10693031879409, -0.33662250574171, 8.9185845355421E-25, 3.0629316876232E-13,
                   -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06, -1.2768608934681E-15,
                   7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07])
    # kJ/(kg K)
    pi = p
    tau = 540 / t
    g0_pi = 1 / pi
    gr_pi = 0
    for i in range(0, 43):
        gr_pi += nr[i] * ir[i] * pi ** (ir[i] - 1) * (tau - 0.5) ** jr[i]

    return __R * t / p * pi * (g0_pi + gr_pi) / 1000


@jit(float64(float64, float64), cache=True, nopython=True)
def h2_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2, Section. 6.1 Basic Equation
    # Table 11 and 12, Page 14 and 15
    j0 = np.array([0, 1, -5, -4, -3, -2, -1, 2, 3])
    n0 = np.array([-9.6927686500217, 10.086655968018, -0.005608791128302,
                   0.071452738081455, -0.40710498223928, 1.4240819171444,
                   -4.383951131945, -0.28408632460772, 0.021268463753307])
    ir = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5,
                   6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20,
                   20, 20, 21, 22, 23, 24, 24, 24])
    jr = np.array([0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7,
                   3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20,
                   35, 48, 21, 53, 39, 26, 40, 58])
    nr = np.array([-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, -0.057581259083432,
                   -0.05032527872793, -3.3032641670203E-05, -1.8948987516315E-04, -3.9392777243355E-03,
                   -0.043797295650573, -2.6674547914087E-05, 2.0481737692309E-08, 4.3870667284435E-07,
                   -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649, -7.8847309559367E-10,
                   1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06, -1.6714766451061E-11,
                   -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06,
                   -0.038946842435739, 1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08,
                   1.0406965210174E-19, -1.0234747095929E-13, -1.0018179379511E-09, -8.0882908646985E-11,
                   0.10693031879409, -0.33662250574171, 8.9185845355421E-25, 3.0629316876232E-13,
                   -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06, -1.2768608934681E-15,
                   7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07])
    # kJ/(kg K)
    pi = p
    tau = 540 / t
    g0_tau = 0
    for i in range(0, 9):
        g0_tau += n0[i] * j0[i] * tau ** (j0[i] - 1)

    gr_tau = 0
    for i in range(0, 43):
        gr_tau += nr[i] * pi ** ir[i] * jr[i] * (tau - 0.5) ** (jr[i] - 1)

    return __R * t * tau * (g0_tau + gr_tau)


@jit(float64(float64, float64), cache=True, nopython=True)
def u2_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2, Section. 6.1 Basic Equation
    # Table 11 and 12, Page 14 and 15
    j0 = np.array([0, 1, -5, -4, -3, -2, -1, 2, 3])
    n0 = np.array([-9.6927686500217, 10.086655968018, -0.005608791128302,
                   0.071452738081455, -0.40710498223928, 1.4240819171444,
                   -4.383951131945, -0.28408632460772, 0.021268463753307])
    ir = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5,
                   6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18,
                   20, 20, 20, 21, 22, 23, 24, 24, 24])
    jr = np.array([0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7,
                   3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50,
                   57, 20, 35, 48, 21, 53, 39, 26, 40, 58])
    nr = np.array([-1.7731742473213E-03, -0.017834862292358, -0.045996013696365,
                   -0.057581259083432, -0.05032527872793, -3.3032641670203E-05,
                   -1.8948987516315E-04, -3.9392777243355E-03, -0.043797295650573, -2.6674547914087E-05,
                   2.0481737692309E-08, 4.3870667284435E-07, -3.227767723857E-05, -1.5033924542148E-03,
                   -0.040668253562649, -7.8847309559367E-10, 1.2790717852285E-08, 4.8225372718507E-07,
                   2.2922076337661E-06, -1.6714766451061E-11, -2.1171472321355E-03, -23.895741934104,
                   -5.905956432427E-18, -1.2621808899101E-06, -0.038946842435739, 1.1256211360459E-11,
                   -8.2311340897998, 1.9809712802088E-08, 1.0406965210174E-19, -1.0234747095929E-13,
                   -1.0018179379511E-09, -8.0882908646985E-11, 0.10693031879409, -0.33662250574171, 8.9185845355421E-25,
                   3.0629316876232E-13, -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06,
                   -1.2768608934681E-15, 7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07])
    # kJ/(kg K)
    pi = p
    tau = 540 / t
    g0_pi = 1 / pi
    g0_tau = 0
    for i in range(0, 9):
        g0_tau += n0[i] * j0[i] * tau ** (j0[i] - 1)

    gr_pi = 0
    gr_tau = 0
    for i in range(0, 43):
        gr_pi += nr[i] * ir[i] * pi ** (ir[i] - 1) * (tau - 0.5) ** jr[i]
        gr_tau += nr[i] * pi ** ir[i] * jr[i] * (tau - 0.5) ** (jr[i] - 1)

    return __R * t * (tau * (g0_tau + gr_tau) - pi * (g0_pi + gr_pi))


@jit(float64(float64, float64), cache=True, nopython=True)
def s2_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2, Section. 6.1 Basic Equation
    # Table 11 and 12, Page 14 and 15
    j0 = np.array([0, 1, -5, -4, -3, -2, -1, 2, 3])
    n0 = np.array([-9.6927686500217, 10.086655968018, -0.005608791128302,
                   0.071452738081455, -0.40710498223928, 1.4240819171444,
                   -4.383951131945, -0.28408632460772, 0.021268463753307])
    ir = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5,
                   6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20, 20,
                   20, 21, 22, 23, 24, 24, 24])
    jr = np.array([0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3,
                   16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20, 35, 48,
                   21, 53, 39, 26, 40, 58])
    nr = np.array([-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, -0.057581259083432,
                   -0.05032527872793, -3.3032641670203E-05, -1.8948987516315E-04, -3.9392777243355E-03,
                   -0.043797295650573, -2.6674547914087E-05, 2.0481737692309E-08, 4.3870667284435E-07,
                   -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649, -7.8847309559367E-10,
                   1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06, -1.6714766451061E-11,
                   -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06,
                   -0.038946842435739, 1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08,
                   1.0406965210174E-19, -1.0234747095929E-13, -1.0018179379511E-09, -8.0882908646985E-11,
                   0.10693031879409, -0.33662250574171, 8.9185845355421E-25, 3.0629316876232E-13,
                   -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06, -1.2768608934681E-15,
                   7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07])
    # kJ/(kg K)
    pi = p
    tau = 540 / t
    g0 = math.log(pi)
    g0_tau = 0
    for i in range(0, 9):
        g0 += n0[i] * tau ** j0[i]
        g0_tau += n0[i] * j0[i] * tau ** (j0[i] - 1)

    gr = 0
    gr_tau = 0
    for i in range(0, 43):
        gr += nr[i] * pi ** ir[i] * (tau - 0.5) ** jr[i]
        gr_tau += nr[i] * pi ** ir[i] * jr[i] * (tau - 0.5) ** (jr[i] - 1)

    return __R * (tau * (g0_tau + gr_tau) - (g0 + gr))


@jit(float64(float64, float64), cache=True, nopython=True)
def cp2_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2, Section. 6.1 Basic Equation
    # Table 11 and 12, Page 14 and 15
    j0 = np.array([0, 1, -5, -4, -3, -2, -1, 2, 3])
    n0 = np.array([-9.6927686500217, 10.086655968018, -0.005608791128302,
                   0.071452738081455, -0.40710498223928, 1.4240819171444,
                   -4.383951131945, -0.28408632460772, 0.021268463753307])
    ir = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                   4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10,
                   16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24])
    jr = np.array([0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35,
                   1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4,
                   10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58])
    nr = np.array([-1.7731742473213E-03, -0.017834862292358, -0.045996013696365,
                   -0.057581259083432, -0.05032527872793, -3.3032641670203E-05, -1.8948987516315E-04,
                   -3.9392777243355E-03, -0.043797295650573, -2.6674547914087E-05, 2.0481737692309E-08,
                   4.3870667284435E-07, -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649,
                   -7.8847309559367E-10, 1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06,
                   -1.6714766451061E-11, -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18,
                   -1.2621808899101E-06, -0.038946842435739, 1.1256211360459E-11, -8.2311340897998,
                   1.9809712802088E-08, 1.0406965210174E-19, -1.0234747095929E-13, -1.0018179379511E-09,
                   -8.0882908646985E-11, 0.10693031879409, -0.33662250574171, 8.9185845355421E-25,
                   3.0629316876232E-13, -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06,
                   -1.2768608934681E-15, 7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07])
    # kJ/(kg K)
    pi = p
    tau = 540 / t
    g0_tautau = 0
    for i in range(0, 9):
        g0_tautau += n0[i] * j0[i] * (j0[i] - 1) * tau ** (j0[i] - 2)

    gr_tautau = 0
    for i in range(0, 43):
        gr_tautau += nr[i] * pi ** ir[i] * jr[i] * (jr[i] - 1) * (tau - 0.5) ** (jr[i] - 2)

    return -__R * tau ** 2 * (g0_tautau + gr_tautau)


@jit(float64(float64, float64), cache=True, nopython=True)
def cv2_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2, Section. 6.1 Basic Equation
    # Table 11 and 12, Page 14 and 15
    j0 = np.array([0, 1, -5, -4, -3, -2, -1, 2, 3])
    n0 = np.array([-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455,
                   -0.40710498223928, 1.4240819171444, -4.383951131945, -0.28408632460772, 0.021268463753307])
    ir = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6,
                   7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24])
    jr = np.array([0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0,
                   11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58])
    nr = np.array([-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, -0.057581259083432,
                   -0.05032527872793, -3.3032641670203E-05, -1.8948987516315E-04, -3.9392777243355E-03,
                   -0.043797295650573, -2.6674547914087E-05, 2.0481737692309E-08, 4.3870667284435E-07,
                   -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649, -7.8847309559367E-10,
                   1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06, -1.6714766451061E-11,
                   -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06,
                   -0.038946842435739, 1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08,
                   1.0406965210174E-19, -1.0234747095929E-13, -1.0018179379511E-09, -8.0882908646985E-11,
                   0.10693031879409, -0.33662250574171, 8.9185845355421E-25, 3.0629316876232E-13,
                   -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06, -1.2768608934681E-15,
                   7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07])
    # kJ/(kg K)
    pi = p
    tau = 540 / t
    g0_tautau = 0
    for i in range(0, 9):
        g0_tautau += n0[i] * j0[i] * (j0[i] - 1) * tau ** (j0[i] - 2)

    gr_pi = 0
    gr_pitau = 0
    gr_pipi = 0
    gr_tautau = 0
    for i in range(0, 43):
        gr_pi += nr[i] * ir[i] * pi ** (ir[i] - 1) * (tau - 0.5) ** jr[i]
        gr_pipi += nr[i] * ir[i] * (ir[i] - 1) * pi ** (ir[i] - 2) * (tau - 0.5) ** jr[i]
        gr_pitau += nr[i] * ir[i] * pi ** (ir[i] - 1) * jr[i] * (tau - 0.5) ** (jr[i] - 1)
        gr_tautau += nr[i] * pi ** ir[i] * jr[i] * (jr[i] - 1) * (tau - 0.5) ** (jr[i] - 2)

    return __R * (
        -tau ** 2 * (g0_tautau + gr_tautau) - (1 + pi * gr_pi - tau * pi * gr_pitau) ** 2 / (1 - pi ** 2 * gr_pipi))


@jit(float64(float64, float64), cache=True, nopython=True)
def w2_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2, Section. 6.1 Basic Equation
    # Table 11 and 12, Page 14 and 15
    j0 = np.array([0, 1, -5, -4, -3, -2, -1, 2, 3])
    n0 = np.array([-9.6927686500217, 10.086655968018, -0.005608791128302,
                   0.071452738081455, -0.40710498223928, 1.4240819171444,
                   -4.383951131945, -0.28408632460772, 0.021268463753307])
    ir = np.array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                   4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10,
                   16, 16, 18, 20, 20, 20, 21, 22, 23, 24, 24, 24])
    jr = np.array([0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35,
                   1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4,
                   10, 14, 29, 50, 57, 20, 35, 48, 21, 53, 39, 26, 40, 58])
    nr = np.array([-1.7731742473213E-03, -0.017834862292358, -0.045996013696365,
                   -0.057581259083432, -0.05032527872793, -3.3032641670203E-05,
                   -1.8948987516315E-04, -3.9392777243355E-03, -0.043797295650573,
                   -2.6674547914087E-05, 2.0481737692309E-08, 4.3870667284435E-07,
                   -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649,
                   -7.8847309559367E-10, 1.2790717852285E-08, 4.8225372718507E-07,
                   2.2922076337661E-06, -1.6714766451061E-11, -2.1171472321355E-03,
                   -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06,
                   -0.038946842435739, 1.1256211360459E-11, -8.2311340897998,
                   1.9809712802088E-08, 1.0406965210174E-19, -1.0234747095929E-13,
                   -1.0018179379511E-09, -8.0882908646985E-11, 0.10693031879409,
                   -0.33662250574171, 8.9185845355421E-25, 3.0629316876232E-13,
                   -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06,
                   -1.2768608934681E-15, 7.3087610595061E-29, 5.5414715350778E-17,
                   -9.436970724121E-07])
    # kJ/(kg K)
    pi = p
    tau = 540 / t
    g0_tautau = 0
    for i in range(0, 9):
        g0_tautau += n0[i] * j0[i] * (j0[i] - 1) * tau ** (j0[i] - 2)

    gr_pi = 0
    gr_pitau = 0
    gr_pipi = 0
    gr_tautau = 0
    for i in range(0, 43):
        gr_pi += nr[i] * ir[i] * pi ** (ir[i] - 1) * (tau - 0.5) ** jr[i]
        gr_pipi += nr[i] * ir[i] * (ir[i] - 1) * pi ** (ir[i] - 2) * (tau - 0.5) ** jr[i]
        gr_pitau += nr[i] * ir[i] * pi ** (ir[i] - 1) * jr[i] * (tau - 0.5) ** (jr[i] - 1)
        gr_tautau += nr[i] * pi ** ir[i] * jr[i] * (jr[i] - 1) * (tau - 0.5) ** (jr[i] - 2)

    return (1000 * __R * t * (1 + 2 * pi * gr_pi + pi ** 2 * gr_pi ** 2) / (
        (1 - pi ** 2 * gr_pipi) + (1 + pi * gr_pi - tau * pi * gr_pitau) ** 2 / (
        tau ** 2 * (g0_tautau + gr_tautau)))) ** 0.5


@jit(float64(float64, float64), cache=True, nopython=True)
def t2_ph(p, h):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2,6.3.1 The Backward Equations T( p, h ) for Sub-regions 2a, 2b, and 2c
    if p < 4:
        sub_reg = 1
    else:
        if p < (905.84278514723 - 0.67955786399241 * h + 1.2809002730136E-04 * h ** 2):
            sub_reg = 2
        else:
            sub_reg = 3

    if sub_reg == 1:
        # Sub-region A
        # Table 20, Eq 22, page 22
        ji = np.array([0, 1, 2, 3, 7, 20, 0, 1, 2, 3, 7, 9, 11, 18, 44,
                       0, 2, 7, 36, 38, 40, 42, 44, 24, 44, 12, 32, 44, 32, 36,
                       42, 34, 44, 28])
        ii = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
                       2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7])
        ni = np.array([1089.8952318288, 849.51654495535, -107.81748091826,
                       33.153654801263, -7.4232016790248, 11.765048724356,
                       1.844574935579, -4.1792700549624, 6.2478196935812,
                       -17.344563108114, -200.58176862096, 271.96065473796,
                       -455.11318285818, 3091.9688604755, 252266.40357872,
                       -6.1707422868339E-03, -0.31078046629583, 11.670873077107,
                       128127984.04046, -985549096.23276, 2822454697.3002,
                       -3594897141.0703, 1722734991.3197, -13551.334240775,
                       12848734.66465, 1.3865724283226, 235988.32556514,
                       -13105236.545054, 7399.9835474766, -551966.9703006,
                       3715408.5996233, 19127.72923966, -415351.64835634,
                       -62.459855192507])
        ts = 0
        hs = h / 2000
        for i in range(0, 34):
            ts += ni[i] * p ** (ii[i]) * (hs - 2.1) ** ji[i]

        return ts
    elif sub_reg == 2:
        # Sub-region B
        # Table 21, Eq 23, page 23
        ji = np.array([0, 1, 2, 12, 18, 24, 28, 40, 0, 2, 6, 12, 18,
                       24, 28, 40, 2, 8, 18, 40, 1, 2, 12, 24, 2, 12,
                       18, 24, 28, 40, 18, 24, 40, 28, 2, 28, 1, 40])
        ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
                       2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5,
                       5, 6, 7, 7, 9, 9])
        ni = np.array([1489.5041079516, 743.07798314034, -97.708318797837,
                       2.4742464705674, -0.63281320016026, 1.1385952129658,
                       -0.47811863648625, 8.5208123431544E-03, 0.93747147377932,
                       3.3593118604916, 3.3809355601454, 0.16844539671904, 0.73875745236695,
                       -0.47128737436186, 0.15020273139707, -0.002176411421975, -0.021810755324761,
                       -0.10829784403677, -0.046333324635812, 7.1280351959551E-05, 1.1032831789999E-04,
                       1.8955248387902E-04, 3.0891541160537E-03, 1.3555504554949E-03, 2.8640237477456E-07,
                       -1.0779857357512E-05, -7.6462712454814E-05, 1.4052392818316E-05, -3.1083814331434E-05,
                       -1.0302738212103E-06, 2.821728163504E-07, 1.2704902271945E-06, 7.3803353468292E-08,
                       -1.1030139238909E-08, -8.1456365207833E-14, -2.5180545682962E-11, -1.7565233969407E-18,
                       8.6934156344163E-15])
        ts = 0
        hs = h / 2000
        for i in range(0, 38):
            ts += ni[i] * (p - 2) ** (ii[i]) * (hs - 2.6) ** ji[i]

        return ts
    else:
        # Sub-region C
        # Table 22, Eq 24, page 24
        ji = np.array([0, 4, 0, 2, 0, 2, 0, 1, 0, 2, 0, 1, 4, 8, 4, 0, 1, 4, 10, 12, 16, 20, 22])
        ii = np.array([-7, -7, -6, -6, -5, -5, -2, -2, -1, -1, 0, 0, 1, 1, 2, 6, 6, 6, 6, 6, 6, 6, 6])
        ni = np.array([-3236839855524.2, 7326335090218.1, 358250899454.47, -583401318515.9,
                       -10783068217.47, 20825544563.171, 610747.83564516, 859777.2253558,
                       -25745.72360417, 31081.088422714, 1208.2315865936, 482.19755109255,
                       3.7966001272486, -10.842984880077, -0.04536417267666, 1.4559115658698E-13,
                       1.126159740723E-12, -1.7804982240686E-11, 1.2324579690832E-07, -1.1606921130984E-06,
                       2.7846367088554E-05, -5.9270038474176E-04, 1.2918582991878E-03])
        ts = 0
        hs = h / 2000
        for i in range(0, 23):
            ts += ni[i] * (p + 25) ** (ii[i]) * (hs - 1.8) ** ji[i]

        return ts


@jit(float64(float64, float64), cache=True, nopython=True)
def t2_ps(p, s):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 6 Equations for region 2,6.3.2 The Backward Equations T( p, s ) for Sub-regions 2a, 2b, and 2c
    # Page 26
    if p < 4:
        sub_reg = 1
    else:
        if s < 5.85:
            sub_reg = 3
        else:
            sub_reg = 2

    if sub_reg == 1:
        # Sub-region A
        # Table 25, Eq 25, page 26
        ii = np.array([-1.5, -1.5, -1.5, -1.5, -1.5, -1.5, -1.25, -1.25, -1.25,
                       -1, -1, -1, -1, -1, -1, -0.75, -0.75, -0.5, -0.5, -0.5,
                       -0.5, -0.25, -0.25, -0.25, -0.25, 0.25, 0.25, 0.25, 0.25,
                       0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.75, 0.75, 0.75, 0.75,
                       1, 1, 1.25, 1.25, 1.5, 1.5])
        ji = np.array([-24, -23, -19, -13, -11, -10, -19, -15, -6, -26, -21, -17,
                       -16, -9, -8, -15, -14, -26, -13, -9, -7, -27, -25, -11, -6,
                       1, 4, 8, 11, 0, 1, 5, 6, 10, 14, 16, 0, 4, 9, 17, 7, 18, 3,
                       15, 5, 18])
        ni = np.array([-392359.83861984, 515265.7382727, 40482.443161048, -321.93790923902,
                       96.961424218694, -22.867846371773, -449429.14124357, -5011.8336020166,
                       0.35684463560015, 44235.33584819, -13673.388811708, 421632.60207864,
                       22516.925837475, 474.42144865646, -149.31130797647, -197811.26320452,
                       -23554.39947076, -19070.616302076, 55375.669883164, 3829.3691437363,
                       -603.91860580567, 1936.3102620331, 4266.064369861, -5978.0638872718,
                       -704.01463926862, 338.36784107553, 20.862786635187, 0.033834172656196,
                       -4.3124428414893E-05, 166.53791356412, -139.86292055898, -0.78849547999872,
                       0.072132411753872, -5.9754839398283E-03, -1.2141358953904E-05, 2.3227096733871E-07,
                       -10.538463566194, 2.0718925496502, -0.072193155260427, 2.074988708112E-07,
                       -0.018340657911379, 2.9036272348696E-07, 0.21037527893619, 2.5681239729999E-04,
                       -0.012799002933781, -8.2198102652018E-06])
        pi = p
        sigma = s / 2
        teta = 0
        for i in range(0, 46):
            teta += ni[i] * pi ** ii[i] * (sigma - 2) ** ji[i]

        return teta

    elif sub_reg == 2:
        # Sub-region B
        # Table 26, Eq 26, page 27
        ik = np.array([-6, -6, -5, -5, -4, -4, -4, -3, -3, -3, -3,
                       -2, -2, -2, -2, -1, -1, -1, -1, -1, 0, 0, 0,
                       0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3,
                       3, 4, 4, 5, 5, 5])
        ji = np.array([0, 11, 0, 11, 0, 1, 11, 0, 1, 11, 12, 0, 1, 6,
                       10, 0, 1, 5, 8, 9, 0, 1, 2, 4, 5, 6, 9, 0, 1,
                       2, 3, 7, 8, 0, 1, 5, 0, 1, 3, 0, 1, 0, 1, 2])
        ni = np.array([316876.65083497, 20.864175881858, -398593.99803599, -21.816058518877,
                       223697.85194242, -2784.1703445817, 9.920743607148, -75197.512299157,
                       2970.8605951158, -3.4406878548526, 0.38815564249115, 17511.29508575,
                       -1423.7112854449, 1.0943803364167, 0.89971619308495, -3375.9740098958,
                       471.62885818355, -1.9188241993679, 0.41078580492196, -0.33465378172097,
                       1387.0034777505, -406.63326195838, 41.72734715961, 2.1932549434532,
                       -1.0320050009077, 0.35882943516703, 5.2511453726066E-03, 12.838916450705,
                       -2.8642437219381, 0.56912683664855, -0.099962954584931, -3.2632037778459E-03,
                       2.3320922576723E-04, -0.1533480985745, 0.029072288239902, 3.7534702741167E-04,
                       1.7296691702411E-03, -3.8556050844504E-04, -3.5017712292608E-05, -1.4566393631492E-05,
                       5.6420857267269E-06, 4.1286150074605E-08, -2.0684671118824E-08, 1.6409393674725E-09])
        pi = p
        sigma = s / 0.7853
        teta = 0
        for i in range(0, 44):
            teta += ni[i] * pi ** ik[i] * (10 - sigma) ** ji[i]

        return teta
    else:
        # Sub-region C
        # Table 27, Eq 27, page 28
        ik = np.array([-2, -2, -1, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,
                       3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7, 7, 7])
        ji = np.array([0, 1, 0, 0, 1, 2, 3, 0, 1, 3, 4, 0, 1, 2, 0, 1,
                       5, 0, 1, 4, 0, 1, 2, 0, 1, 0, 1, 3, 4, 5])
        ni = np.array([909.68501005365, 2404.566708842, -591.6232638713,
                       541.45404128074, -270.98308411192, 979.76525097926,
                       -469.66772959435, 14.399274604723, -19.104204230429,
                       5.3299167111971, -21.252975375934, -0.3114733441376,
                       0.60334840894623, -0.042764839702509, 5.8185597255259E-03,
                       -0.014597008284753, 5.6631175631027E-03, -7.6155864584577E-05,
                       2.2440342919332E-04, -1.2561095013413E-05, 6.3323132660934E-07,
                       -2.0541989675375E-06, 3.6405370390082E-08, -2.9759897789215E-09,
                       1.0136618529763E-08, 5.9925719692351E-12, -2.0677870105164E-11,
                       -2.0874278181886E-11, 1.0162166825089E-10, -1.6429828281347E-10])
        pi = p
        sigma = s / 2.9251
        teta = 0
        for i in range(0, 30):
            teta += ni[i] * pi ** ik[i] * (2 - sigma) ** ji[i]

        return teta


@jit(float64(float64, float64), cache=True, nopython=True)
def p2_hs(h, s):
    # Supplementary Release on Backward Equations for Pressure as a
    # def of Enthalpy and Entropy p(h,s) to the
    # IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # Chapter 6:Backward Equations p(h,s) for region 2
    if h < (-3498.98083432139 + 2575.60716905876 * s - 421.073558227969 * s ** 2 + 27.6349063799944 * s ** 3):
        sub_reg = 1
    else:
        if s < 5.85:
            sub_reg = 3
        else:
            sub_reg = 2

    if sub_reg == 1:
        # Sub-region A
        # Table 6, Eq 3, page 8
        ii = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                       2, 2, 2, 3, 3, 3, 3, 3, 4, 5, 5, 6, 7])
        ji = np.array([1, 3, 6, 16, 20, 22, 0, 1, 2, 3, 5, 6, 10, 16,
                       20, 22, 3, 16, 20, 0, 2, 3, 6, 16, 16, 3, 16, 3, 1])
        ni = np.array([-1.82575361923032E-02, -0.125229548799536, 0.592290437320145,
                       6.04769706185122, 238.624965444474, -298.639090222922, 0.051225081304075,
                       -0.437266515606486, 0.413336902999504, -5.16468254574773, -5.57014838445711,
                       12.8555037824478, 11.414410895329, -119.504225652714, -2847.7798596156,
                       4317.57846408006, 1.1289404080265, 1974.09186206319, 1516.12444706087,
                       1.41324451421235E-02, 0.585501282219601, -2.97258075863012, 5.94567314847319,
                       -6236.56565798905, 9659.86235133332, 6.81500934948134, -6332.07286824489,
                       -5.5891922446576, 4.00645798472063E-02])
        eta = h / 4200
        sigma = s / 12
        pi = 0
        for i in range(0, 29):
            pi += ni[i] * (eta - 0.5) ** ii[i] * (sigma - 1.2) ** ji[i]

        return pi ** 4 * 4
    elif sub_reg == 2:
        # Sub-region B
        # Table 7, Eq 4, page 9
        ii = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3,
                       4, 4, 5, 5, 6, 6, 6, 7, 7, 8, 8, 8, 8, 12, 14])
        ji = np.array([0, 1, 2, 4, 8, 0, 1, 2, 3, 5, 12, 1, 6, 18, 0, 1, 7, 12,
                       1, 16, 1, 12, 1, 8, 18, 1, 16, 1, 3, 14, 18, 10, 16])
        ni = np.array([8.01496989929495E-02, -0.543862807146111, 0.337455597421283,
                       8.9055545115745, 313.840736431485, 0.797367065977789, -1.2161697355624,
                       8.72803386937477, -16.9769781757602, -186.552827328416, 95115.9274344237,
                       -18.9168510120494, -4334.0703719484, 543212633.012715, 0.144793408386013,
                       128.024559637516, -67230.9534071268, 33697238.0095287, -586.63419676272,
                       -22140322476.9889, 1716.06668708389, -570817595.806302, -3121.09693178482,
                       -2078413.8463301, 3056059461577.86, 3221.57004314333, 326810259797.295,
                       -1441.04158934487, 410.694867802691, 109077066873.024, -24796465425889.3,
                       1888019068.65134, -123651009018773])
        eta = h / 4100
        sigma = s / 7.9
        pi = 0
        for i in range(0, 33):
            pi += ni[i] * (eta - 0.6) ** ii[i] * (sigma - 1.01) ** ji[i]

        return pi ** 4 * 100
    else:
        # Sub-region C
        # Table 8, Eq 5, page 10
        ii = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
                       3, 3, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 10, 12, 16])
        ji = np.array([0, 1, 2, 3, 4, 8, 0, 2, 5, 8, 14, 2, 3, 7, 10, 18,
                       0, 5, 8, 16, 18, 18, 1, 4, 6, 14, 8, 18, 7, 7, 10])
        ni = np.array([0.112225607199012, -3.39005953606712, -32.0503911730094,
                       -197.5973051049, -407.693861553446, 13294.3775222331,
                       1.70846839774007, 37.3694198142245, 3581.44365815434,
                       423014.446424664, -751071025.760063, 52.3446127607898,
                       -228.351290812417, -960652.417056937, -80705929.2526074,
                       1626980172256.69, 0.772465073604171, 46392.9973837746,
                       -13731788.5134128, 1704703926305.12, -25110462818730.8,
                       31774883083552, 53.8685623675312, -55308.9094625169,
                       -1028615.22421405, 2042494187562.34, 273918446.626977,
                       -2.63963146312685E+15, -1078908541.08088, -29649262098.0124,
                       -1.11754907323424E+15])
        eta = h / 3500
        sigma = s / 5.9
        pi = 0
        for i in range(0, 31):
            pi += ni[i] * (eta - 0.7) ** ii[i] * (sigma - 1.1) ** ji[i]

        return pi ** 4 * 100


@jit(float64(float64), cache=True, nopython=True)
def b23t_p(p):
    # Release on the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # 1997
    # Section 4 Auxiliary Equation for the Boundary between Regions 2 and 3
    # Eq 6, Page 6
    return 572.54459862746 + ((p - 13.91883977887) / 1.0192970039326E-03) ** 0.5


@jit(float64(float64, float64), cache=True, nopython=True)
def t2_prho(p, rho):
    # Solve by iteration. Observe that fo low temperatures this equation has 2 solutions.
    # Solve with half interval method

    if p < 16.5292:
        low_bound = t4_p(p)
    else:
        low_bound = b23t_p(p)

    high_bound = 1073.15
    rhos = -1000
    ts = 0
    while abs(rho - rhos) > 0.000001:
        ts = (low_bound + high_bound) / 2
        rhos = 1 / v2_pt(p, ts)
        if rhos < rho:
            high_bound = ts
        else:
            low_bound = ts

    return ts


# ***********************************************************************************************************
# *2.3 functions for region 3
@jit(float64(float64, float64), cache=True, nopython=True)
def p3_rhot(rho, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 7 Basic Equation for region 3, Section. 6.1 Basic Equation
    # Table 30 and 31, Page 30 and 31
    ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                   4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11])
    ji = np.array([0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26,
                   0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26])
    ni = np.array([1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716,
                   2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502E-03,
                   -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607,
                   0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965,
                   0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946,
                   -2.018991502357, -8.2147637173963E-03, -0.47596035734923, 0.0439840744735,
                   -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332,
                   -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092,
                   0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084E-04,
                   3.2308904703711E-03, 8.0964802996215E-05, -1.6557679795037E-04, -4.4923899061815E-05])
    # kJ/(KgK)
    tc = 647.096  # K
    # pc = 22.064  # MPa
    rhoc = 322  # kg/m3
    delta = rho / rhoc
    tau = tc / t
    fidelta = 0
    for i in range(1, 40):
        fidelta += ni[i] * ii[i] * delta ** (ii[i] - 1) * tau ** ji[i]

    fidelta += ni[0] / delta
    return rho * __R * t * delta * fidelta / 1000


@jit(float64(float64, float64), cache=True, nopython=True)
def u3_rhot(rho, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 7 Basic Equation for region 3, Section. 6.1 Basic Equation
    # Table 30 and 31, Page 30 and 31
    ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                   4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11])
    ji = np.array([0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4,
                   16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26])
    ni = np.array([1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716,
                   2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502E-03,
                   -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607,
                   0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965,
                   0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946,
                   -2.018991502357, -8.2147637173963E-03, -0.47596035734923, 0.0439840744735,
                   -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332,
                   -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092,
                   0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084E-04,
                   3.2308904703711E-03, 8.0964802996215E-05, -1.6557679795037E-04, -4.4923899061815E-05])
    # kJ/(KgK)
    tc = 647.096  # K
    # pc = 22.064  # MPa
    rhoc = 322  # kg/m3
    delta = rho / rhoc
    tau = tc / t
    fitau = 0
    for i in range(1, 40):
        fitau += ni[i] * delta ** ii[i] * ji[i] * tau ** (ji[i] - 1)

    return __R * t * (tau * fitau)


@jit(float64(float64, float64), cache=True, nopython=True)
def h3_rhot(rho, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 7 Basic Equation for region 3, Section. 6.1 Basic Equation
    # Table 30 and 31, Page 30 and 31
    ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
                   2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                   4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11])
    ji = np.array([0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2,
                   6, 7, 22, 26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26,
                   2, 26, 2, 26, 0, 1, 26])
    ni = np.array([1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954,
                   -2.808078114862, 1.2053369696517, -8.4566812812502E-03, -1.2654315477714, -1.1524407806681,
                   0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877,
                   -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946,
                   -2.018991502357, -8.2147637173963E-03, -0.47596035734923, 0.0439840744735, -0.44476435428739,
                   0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158,
                   -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472,
                   5.7922953628084E-04, 3.2308904703711E-03, 8.0964802996215E-05, -1.6557679795037E-04,
                   -4.4923899061815E-05])
    # kJ/(KgK)
    tc = 647.096  # K
    # pc = 22.064  # MPa
    rhoc = 322  # kg/m3
    delta = rho / rhoc
    tau = tc / t
    fidelta = 0
    fitau = 0
    for i in range(1, 40):
        fidelta += ni[i] * ii[i] * delta ** (ii[i] - 1) * tau ** ji[i]
        fitau += ni[i] * delta ** ii[i] * ji[i] * tau ** (ji[i] - 1)

    fidelta += ni[0] / delta
    return __R * t * (tau * fitau + delta * fidelta)


@jit(float64(float64, float64), cache=True, nopython=True)
def s3_rhot(rho, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 7 Basic Equation for region 3, Section. 6.1 Basic Equation
    # Table 30 and 31, Page 30 and 31
    ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
                   3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11])
    ji = np.array([0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22,
                   26, 0, 2, 4, 16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2,
                   26, 0, 1, 26])
    ni = np.array([1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716,
                   2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502E-03,
                   -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607,
                   0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965,
                   0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946,
                   -2.018991502357, -8.2147637173963E-03, -0.47596035734923, 0.0439840744735,
                   -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332,
                   -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092,
                   0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084E-04,
                   3.2308904703711E-03, 8.0964802996215E-05, -1.6557679795037E-04, -4.4923899061815E-05])
    # kJ/(KgK)
    tc = 647.096  # K
    # pc = 22.064  # MPa
    rhoc = 322  # kg/m3
    delta = rho / rhoc
    tau = tc / t
    fi = 0
    fitau = 0
    for i in range(1, 40):
        fi += ni[i] * delta ** ii[i] * tau ** ji[i]
        fitau += ni[i] * delta ** ii[i] * ji[i] * tau ** (ji[i] - 1)

    fi += ni[0] * math.log(delta)
    return __R * (tau * fitau - fi)


@jit(float64(float64, float64), cache=True, nopython=True)
def cp3_rhot(rho, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 7 Basic Equation for region 3, Section. 6.1 Basic Equation
    # Table 30 and 31, Page 30 and 31
    ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                   4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11])
    ji = np.array([0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4,
                   16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26])
    ni = np.array([1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716,
                   2.6185947787954, -2.808078114862, 1.2053369696517, -8.4566812812502E-03,
                   -1.2654315477714, -1.1524407806681, 0.88521043984318, -0.64207765181607,
                   0.38493460186671, -0.85214708824206, 4.8972281541877, -3.0502617256965,
                   0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946,
                   -2.018991502357, -8.2147637173963E-03, -0.47596035734923, 0.0439840744735,
                   -0.44476435428739, 0.90572070719733, 0.70522450087967, 0.10770512626332,
                   -0.32913623258954, -0.50871062041158, -0.022175400873096, 0.094260751665092,
                   0.16436278447961, -0.013503372241348, -0.014834345352472, 5.7922953628084E-04,
                   3.2308904703711E-03, 8.0964802996215E-05, -1.6557679795037E-04, -4.4923899061815E-05])
    # kJ/(KgK)
    tc = 647.096  # K
    # pc = 22.064  # MPa
    rhoc = 322  # kg/m3
    delta = rho / rhoc
    tau = tc / t
    fitautau = 0
    fidelta = 0
    fideltatau = 0
    fideltadelta = 0
    for i in range(1, 40):
        fitautau += ni[i] * delta ** ii[i] * ji[i] * (ji[i] - 1) * tau ** (ji[i] - 2)
        fidelta += ni[i] * ii[i] * delta ** (ii[i] - 1) * tau ** ji[i]
        fideltatau += ni[i] * ii[i] * delta ** (ii[i] - 1) * ji[i] * tau ** (ji[i] - 1)
        fideltadelta += ni[i] * ii[i] * (ii[i] - 1) * delta ** (ii[i] - 2) * tau ** ji[i]

    fidelta += ni[0] / delta
    fideltadelta -= ni[0] / (delta ** 2)
    return __R * (-tau ** 2 * fitautau + (delta * fidelta - delta * tau * fideltatau) ** 2 / (
        2 * delta * fidelta + delta ** 2 * fideltadelta))


@jit(float64(float64, float64), cache=True, nopython=True)
def cv3_rhot(rho, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 7 Basic Equation for region 3, Section. 6.1 Basic Equation
    # Table 30 and 31, Page 30 and 31
    ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
                   4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11])
    ji = np.array([0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4,
                   16, 26, 0, 2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26])
    ni = np.array([1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954,
                   -2.808078114862, 1.2053369696517, -8.4566812812502E-03, -1.2654315477714, -1.1524407806681,
                   0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877,
                   -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946,
                   -2.018991502357, -8.2147637173963E-03, -0.47596035734923, 0.0439840744735, -0.44476435428739,
                   0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954, -0.50871062041158,
                   -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348, -0.014834345352472,
                   5.7922953628084E-04, 3.2308904703711E-03, 8.0964802996215E-05, -1.6557679795037E-04,
                   -4.4923899061815E-05])
    # kJ/(KgK)
    tc = 647.096  # K
    # pc = 22.064  # MPa
    rhoc = 322  # kg/m3
    delta = rho / rhoc
    tau = tc / t
    fitautau = 0
    for i in range(0, 40):
        fitautau += ni[i] * delta ** ii[i] * ji[i] * (ji[i] - 1) * tau ** (ji[i] - 2)

    return __R * -(tau * tau * fitautau)


@jit(float64(float64, float64), cache=True, nopython=True)
def w3_rhot(rho, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # 7 Basic Equation for region 3, Section. 6.1 Basic Equation
    # Table 30 and 31, Page 30 and 31
    ii = np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4,
                   5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 10, 10, 11])
    ji = np.array([0, 0, 1, 2, 7, 10, 12, 23, 2, 6, 15, 17, 0, 2, 6, 7, 22, 26, 0, 2, 4, 16, 26, 0,
                   2, 4, 26, 1, 3, 26, 0, 2, 26, 2, 26, 2, 26, 0, 1, 26])
    ni = np.array([1.0658070028513, -15.732845290239, 20.944396974307, -7.6867707878716, 2.6185947787954,
                   -2.808078114862, 1.2053369696517, -8.4566812812502E-03, -1.2654315477714, -1.1524407806681,
                   0.88521043984318, -0.64207765181607, 0.38493460186671, -0.85214708824206, 4.8972281541877,
                   -3.0502617256965, 0.039420536879154, 0.12558408424308, -0.2799932969871, 1.389979956946,
                   -2.018991502357, -8.2147637173963E-03, -0.47596035734923, 0.0439840744735, -0.44476435428739,
                   0.90572070719733, 0.70522450087967, 0.10770512626332, -0.32913623258954,
                   -0.50871062041158, -0.022175400873096, 0.094260751665092, 0.16436278447961, -0.013503372241348,
                   -0.014834345352472, 5.7922953628084E-04, 3.2308904703711E-03, 8.0964802996215E-05,
                   -1.6557679795037E-04, -4.4923899061815E-05])
    # kJ/(KgK)
    tc = 647.096  # K
    # pc = 22.064  # MPa
    rhoc = 322  # kg/m3
    delta = rho / rhoc
    tau = tc / t
    fitautau = 0
    fidelta = 0
    fideltatau = 0
    fideltadelta = 0
    for i in range(1, 40):
        fitautau += ni[i] * delta ** ii[i] * ji[i] * (ji[i] - 1) * tau ** (ji[i] - 2)
        fidelta += ni[i] * ii[i] * delta ** (ii[i] - 1) * tau ** ji[i]
        fideltatau += ni[i] * ii[i] * delta ** (ii[i] - 1) * ji[i] * tau ** (ji[i] - 1)
        fideltadelta += ni[i] * ii[i] * (ii[i] - 1) * delta ** (ii[i] - 2) * tau ** ji[i]

    fidelta += ni[0] / delta
    fideltadelta -= ni[0] / (delta ** 2)
    return (1000 * __R * t * (
        2 * delta * fidelta + delta ** 2 * fideltadelta - (delta * fidelta - delta * tau * fideltatau) ** 2 / (
        tau ** 2 * fitautau))) ** 0.5


@jit(float64(float64, float64), cache=True, nopython=True)
def t3_ph(p, h):
    # Revised Supplementary Release on Backward Equations for the
    # functions T(p,h), v(p,h) and T(p,s), v(p,s) for region 3 of the
    # IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # 2004
    # Section 3.3 Backward Equations T(p,h) and v(p,h) for Sub-regions 3a and 3b
    # Boundary equation, Eq 1 Page 5
    h3ab = 2014.64004206875 + 3.74696550136983 * p - 2.19921901054187E-02 * p ** 2 + 8.7513168600995E-05 * p ** 3
    if h < h3ab:
        # Sub-region 3a
        # Eq 2, Table 3, Page 7
        ii = np.array([-12, -12, -12, -12, -12, -12, -12, -12, -10, -10, -10, -8, -8, -8, -8,
                       -5, -3, -2, -2, -2, -1, -1, 0, 0, 1, 3, 3, 4, 4, 10, 12])
        ji = np.array([0, 1, 2, 6, 14, 16, 20, 22, 1, 5, 12, 0, 2, 4, 10, 2, 0, 1, 3, 4, 0, 2,
                       0, 1, 1, 0, 1, 0, 3, 4, 5])
        ni = np.array([-1.33645667811215E-07, 4.55912656802978E-06, -1.46294640700979E-05, 6.3934131297008E-03,
                       372.783927268847, -7186.54377460447, 573494.7521034, -2675693.29111439, -3.34066283302614E-05,
                       -2.45479214069597E-02, 47.8087847764996, 7.64664131818904E-06, 1.28350627676972E-03,
                       1.71219081377331E-02, -8.51007304583213, -1.36513461629781E-02, -3.84460997596657E-06,
                       3.37423807911655E-03, -0.551624873066791, 0.72920227710747, -9.92522757376041E-03,
                       -0.119308831407288, 0.793929190615421, 0.454270731799386, 0.20999859125991,
                       -6.42109823904738E-03, -0.023515586860454, 2.52233108341612E-03, -7.64885133368119E-03,
                       1.36176427574291E-02, -1.33027883575669E-02])
        ps = p / 100
        hs = h / 2300
        ts = 0
        for i in range(0, 31):
            ts += ni[i] * (ps + 0.24) ** ii[i] * (hs - 0.615) ** ji[i]

        return ts * 760
    else:
        # Sub-region 3b
        # Eq 3, Table 4, Page 7,8
        ii = np.array(
            [-12, -12, -10, -10, -10, -10, -10, -8, -8, -8, -8, -8, -6, -6, -6, -4, -4, -3, -2, -2, -1, -1, -1, -1, -1,
             -1, 0, 0, 1, 3, 5, 6, 8])
        ji = np.array([0, 1, 0, 1, 5, 10, 12, 0, 1, 2, 4, 10, 0, 1, 2, 0,
                       1, 5, 0, 4, 2, 4, 6, 10, 14, 16, 0, 2, 1, 1, 1, 1, 1])
        ni = np.array([3.2325457364492E-05, -1.27575556587181E-04, -4.75851877356068E-04, 1.56183014181602E-03,
                       0.105724860113781, -85.8514221132534, 724.140095480911, 2.96475810273257E-03,
                       -5.92721983365988E-03, -1.26305422818666E-02, -0.115716196364853, 84.9000969739595,
                       -1.08602260086615E-02, 1.54304475328851E-02, 7.50455441524466E-02, 2.52520973612982E-02,
                       -6.02507901232996E-02, -3.07622221350501, -5.74011959864879E-02, 5.03471360939849,
                       -0.925081888584834, 3.91733882917546, -77.314600713019, 9493.08762098587, -1410437.19679409,
                       8491662.30819026, 0.861095729446704, 0.32334644281172, 0.873281936020439, -0.436653048526683,
                       0.286596714529479, -0.131778331276228, 6.76682064330275E-03])
        hs = h / 2800
        ps = p / 100
        ts = 0
        for i in range(0, 33):
            ts += ni[i] * (ps + 0.298) ** ii[i] * (hs - 0.72) ** ji[i]

        return ts * 860


@jit(float64(float64, float64), cache=True, nopython=True)
def v3_ph(p, h):
    # Revised Supplementary Release on Backward Equations for the
    # functions T(p,h), v(p,h) and T(p,s), v(p,s) for region 3 of
    # the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # 2004
    # Section 3.3 Backward Equations T(p,h) and v(p,h) for Sub-regions 3a and 3b
    # Boundary equation, Eq 1 Page 5
    h3ab = 2014.64004206875 + 3.74696550136983 * p - 2.19921901054187E-02 * p ** 2 + 8.7513168600995E-05 * p ** 3
    if h < h3ab:
        # Sub-region 3a
        # Eq 4, Table 6, Page 9
        ii = np.array([-12, -12, -12, -12, -10, -10, -10, -8, -8, -6, -6, -6, -4, -4, -3, -2, -2, -1, -1,
                       -1, -1, 0, 0, 1, 1, 1, 2, 2, 3, 4, 5, 8])
        ji = np.array([6, 8, 12, 18, 4, 7, 10, 5, 12, 3, 4, 22, 2, 3, 7, 3, 16, 0, 1, 2, 3, 0, 1, 0, 1, 2,
                       0, 2, 0, 2, 2, 2])
        ni = np.array([5.29944062966028E-03, -0.170099690234461, 11.1323814312927, -2178.98123145125,
                       -5.06061827980875E-04, 0.556495239685324, -9.43672726094016, -0.297856807561527,
                       93.9353943717186, 1.92944939465981E-02,
                       0.421740664704763, -3689141.2628233, -7.37566847600639E-03, -0.354753242424366,
                       -1.99768169338727, 1.15456297059049, 5683.6687581596, 8.08169540124668E-03,
                       0.172416341519307, 1.04270175292927, -0.297691372792847, 0.560394465163593,
                       0.275234661176914, -0.148347894866012, -6.51142513478515E-02, -2.92468715386302,
                       6.64876096952665E-02, 3.52335014263844, -1.46340792313332E-02, -2.24503486668184,
                       1.10533464706142, -4.08757344495612E-02])
        ps = p / 100
        hs = h / 2100
        vs = 0
        for i in range(0, 32):
            vs += ni[i] * (ps + 0.128) ** ii[i] * (hs - 0.727) ** ji[i]

        return vs * 0.0028
    else:
        # Sub-region 3b
        # Eq 5, Table 7, Page 9
        ii = np.array([-12, -12, -8, -8, -8, -8, -8, -8, -6, -6, -6, -6, -6, -6, -4, -4, -4, -3, -3, -2, -2, -1, -1,
                       -1, -1, 0, 1, 1, 2, 2])
        ji = np.array([0, 1, 0, 1, 3, 6, 7, 8, 0, 1, 2, 5, 6, 10, 3, 6, 10, 0, 2, 1, 2, 0, 1, 4, 5, 0, 0, 1, 2, 6])
        ni = np.array([-2.25196934336318E-09, 1.40674363313486E-08, 2.3378408528056E-06, -3.31833715229001E-05,
                       1.07956778514318E-03, -0.271382067378863, 1.07202262490333, -0.853821329075382,
                       -2.15214194340526E-05, 7.6965608822273E-04, -4.31136580433864E-03, 0.453342167309331,
                       -0.507749535873652, -100.475154528389, -0.219201924648793, -3.21087965668917, 607.567815637771,
                       5.57686450685932E-04, 0.18749904002955, 9.05368030448107E-03, 0.285417173048685,
                       3.29924030996098E-02, 0.239897419685483, 4.82754995951394, -11.8035753702231,
                       0.169490044091791, -1.79967222507787E-02, 3.71810116332674E-02, -5.36288335065096E-02,
                       1.6069710109252])
        ps = p / 100
        hs = h / 2800
        vs = 0
        for i in range(0, 30):
            vs += ni[i] * (ps + 0.0661) ** ii[i] * (hs - 0.72) ** ji[i]

        return vs * 0.0088


@jit(float64(float64, float64), cache=True, nopython=True)
def t3_ps(p, s):
    # Revised Supplementary Release on Backward Equations for the functions T(p,h), v(p,h) and T(p,s), v(p,s) for
    # region 3 of the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # 2004
    # 3.4 Backward Equations T(p,s) and v(p,s) for Sub-regions 3a and 3b
    # Boundary equation, Eq 6 Page 11
    if s <= 4.41202148223476:
        # Sub-region 3a
        # Eq 6, Table 10, Page 11
        ii = np.array([-12, -12, -10, -10, -10, -10, -8, -8, -8, -8, -6, -6, -6,
                       -5, -5, -5, -4, -4, -4, -2, -2, -1, -1, 0, 0, 0, 1, 2, 2, 3, 8, 8, 10])
        ji = np.array([28, 32, 4, 10, 12, 14, 5, 7, 8, 28, 2, 6, 32, 0, 14, 32, 6, 10, 36, 1,
                       4, 1, 6, 0, 1, 4, 0, 0, 3, 2, 0, 1, 2])
        ni = np.array([1500420082.63875, -159397258480.424, 5.02181140217975E-04, -67.2057767855466, 1450.58545404456,
                       -8238.8953488889, -0.154852214233853, 11.2305046746695, -29.7000213482822, 43856513263.5495,
                       1.37837838635464E-03, -2.97478527157462, 9717779473494.13, -5.71527767052398E-05,
                       28830.794977842, -74442828926270.3, 12.8017324848921, -368.275545889071, 6.64768904779177E+15,
                       0.044935925195888, -4.22897836099655, -0.240614376434179, -4.74341365254924, 0.72409399912611,
                       0.923874349695897, 3.99043655281015, 3.84066651868009E-02, -3.59344365571848E-03,
                       -0.735196448821653, 0.188367048396131, 1.41064266818704E-04, -2.57418501496337E-03,
                       1.23220024851555E-03])
        sigma = s / 4.4
        pi = p / 100
        teta = 0
        for i in range(0, 33):
            teta += ni[i] * (pi + 0.24) ** ii[i] * (sigma - 0.703) ** ji[i]

        return teta * 760
    else:
        # Sub-region 3b
        # Eq 7, Table 11, Page 11
        ii = np.array([-12, -12, -12, -12, -8, -8, -8, -6, -6, -6, -5, -5,
                       -5, -5, -5, -4, -3, -3, -2, 0, 2, 3, 4, 5, 6, 8, 12, 14])
        ji = np.array([1, 3, 4, 7, 0, 1, 3, 0, 2, 4, 0, 1, 2, 4, 6, 12, 1, 6, 2, 0, 1, 1, 0, 24, 0, 3, 1, 2])
        ni = np.array([0.52711170160166, -40.1317830052742, 153.020073134484, -2247.99398218827, -0.193993484669048,
                       -1.40467557893768, 42.6799878114024, 0.752810643416743, 22.6657238616417, -622.873556909932,
                       -0.660823667935396, 0.841267087271658, -25.3717501764397, 485.708963532948, 880.531517490555,
                       2650155.92794626, -0.359287150025783, -656.991567673753, 2.41768149185367, 0.856873461222588,
                       0.655143675313458, -0.213535213206406, 5.62974957606348E-03, -316955725450471,
                       -6.99997000152457E-04, 1.19845803210767E-02, 1.93848122022095E-05, -2.15095749182309E-05])
        sigma = s / 5.3
        pi = p / 100
        teta = 0
        for i in range(0, 28):
            teta += ni[i] * (pi + 0.76) ** ii[i] * (sigma - 0.818) ** ji[i]

        return teta * 860


@jit(float64(float64, float64), cache=True, nopython=True)
def v3_ps(p, s):
    # Revised Supplementary Release on Backward Equations for the functions
    # T(p,h), v(p,h) and T(p,s), v(p,s) for region 3 of
    # the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # 2004
    # 3.4 Backward Equations T(p,s) and v(p,s) for Sub-regions 3a and 3b
    # Boundary equation, Eq 6 Page 11
    if s <= 4.41202148223476:
        # Sub-region 3a
        # Eq 8, Table 13, Page 14
        ii = np.array([-12, -12, -12, -10, -10, -10, -10, -8, -8, -8, -8, -6, -5, -4, -3, -3, -2,
                       -2, -1, -1, 0, 0, 0, 1, 2, 4, 5, 6])
        ji = np.array([10, 12, 14, 4, 8, 10, 20, 5, 6, 14, 16, 28, 1, 5, 2, 4, 3, 8, 1, 2, 0, 1, 3, 0, 0, 2, 2, 0])
        ni = np.array([79.5544074093975, -2382.6124298459, 17681.3100617787, -1.10524727080379E-03, -15.3213833655326,
                       297.544599376982, -35031520.6871242, 0.277513761062119, -0.523964271036888, -148011.182995403,
                       1600148.99374266, 1708023226634.27, 2.46866996006494E-04, 1.6532608479798, -0.118008384666987,
                       2.537986423559, 0.965127704669424, -28.2172420532826, 0.203224612353823, 1.10648186063513,
                       0.52612794845128, 0.277000018736321, 1.08153340501132, -7.44127885357893E-02,
                       1.64094443541384E-02, -6.80468275301065E-02, 0.025798857610164, -1.45749861944416E-04])
        pi = p / 100
        sigma = s / 4.4
        omega = 0
        for i in range(0, 28):
            omega += ni[i] * (pi + 0.187) ** ii[i] * (sigma - 0.755) ** ji[i]

        return omega * 0.0028
    else:
        # Sub-region 3b
        # Eq 9, Table 14, Page 14
        ii = np.array([-12, -12, -12, -12, -12, -12, -10, -10, -10, -10, -8,
                       -5, -5, -5, -4, -4, -4, -4, -3, -2, -2, -2, -2, -2, -2, 0, 0, 0, 1, 1, 2])
        ji = np.array([0, 1, 2, 3, 5, 6, 0, 1, 2, 4, 0, 1, 2, 3, 0, 1, 2, 3, 1, 0, 1, 2, 3, 4, 12, 0, 1, 2, 0, 2, 2])
        ni = np.array([5.91599780322238E-05, -1.85465997137856E-03, 1.04190510480013E-02, 5.9864730203859E-03,
                       -0.771391189901699, 1.72549765557036, -4.67076079846526E-04, 1.34533823384439E-02,
                       -8.08094336805495E-02, 0.508139374365767, 1.28584643361683E-03, -1.63899353915435,
                       5.86938199318063, -2.92466667918613, -6.14076301499537E-03, 5.76199014049172,
                       -12.1613320606788, 1.67637540957944, -7.44135838773463, 3.78168091437659E-02, 4.01432203027688,
                       16.0279837479185, 3.17848779347728, -3.58362310304853, -1159952.60446827, 0.199256573577909,
                       -0.122270624794624, -19.1449143716586, -1.50448002905284E-02, 14.6407900162154,
                       -3.2747778718823])
        pi = p / 100
        sigma = s / 5.3
        omega = 0
        for i in range(0, 31):
            omega += ni[i] * (pi + 0.298) ** ii[i] * (sigma - 0.816) ** ji[i]

        return omega * 0.0088


@jit(float64(float64, float64), cache=True, nopython=True)
def p3_hs(h, s):
    # Supplementary Release on Backward Equations ( ) , p h s for region 3,
    # Equations as a def of h and s for the region Boundaries, and an Equation
    # ( ) sat , T hs for region 4 of the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam
    # 2004
    # Section 3 Backward functions p(h,s), T(h,s), and v(h,s) for region 3
    if s < 4.41202148223476:
        # Sub-region 3a
        # Eq 1, Table 3, Page 8
        ii = np.array([0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 6, 7, 8,
                       10, 10, 14, 18, 20, 22, 22, 24, 28, 28, 32, 32])
        ji = np.array([0, 1, 5, 0, 3, 4, 8, 14, 6, 16, 0, 2, 3, 0, 1, 4, 5, 28, 28, 24,
                       1, 32, 36, 22, 28, 36, 16, 28, 36, 16, 36, 10, 28])
        ni = np.array([7.70889828326934, -26.0835009128688, 267.416218930389, 17.2221089496844,
                       -293.54233214597, 614.135601882478, -61056.2757725674, -65127225.1118219,
                       73591.9313521937, -11664650591.4191, 35.5267086434461, -596.144543825955,
                       -475.842430145708, 69.6781965359503, 335.674250377312, 25052.6809130882,
                       146997.380630766, 5.38069315091534E+19, 1.43619827291346E+21, 3.64985866165994E+19,
                       -2547.41561156775, 2.40120197096563E+27, -3.93847464679496E+29, 1.47073407024852E+24,
                       -4.26391250432059E+31, 1.94509340621077E+38, 6.66212132114896E+23, 7.06777016552858E+33,
                       1.75563621975576E+41, 1.08408607429124E+28, 7.30872705175151E+43, 1.5914584739887E+24,
                       3.77121605943324E+40])
        sigma = s / 4.4
        eta = h / 2300
        pi = 0
        for i in range(0, 33):
            pi += ni[i] * (eta - 1.01) ** ii[i] * (sigma - 0.75) ** ji[i]

        return pi * 99
    else:
        # Sub-region 3b
        # Eq 2, Table 4, Page 8
        ii = np.array([-12, -12, -12, -12, -12, -10, -10, -10, -10, -8, -8, -6,
                       -6, -6, -6, -5, -4, -4, -4, -3, -3, -3, -3, -2, -2, -1,
                       0, 2, 2, 5, 6, 8, 10, 14, 14])
        ji = np.array([2, 10, 12, 14, 20, 2, 10, 14, 18, 2, 8, 2, 6, 7, 8, 10,
                       4, 5, 8, 1, 3, 5, 6, 0, 1, 0, 3, 0, 1, 0, 1, 1, 1, 3, 7])
        ni = np.array([1.25244360717979E-13, -1.26599322553713E-02, 5.06878030140626,
                       31.7847171154202, -391041.161399932, -9.75733406392044E-11, -18.6312419488279,
                       510.973543414101, 373847.005822362, 2.99804024666572E-08, 20.0544393820342,
                       -4.98030487662829E-06, -10.230180636003, 55.2819126990325, -206.211367510878,
                       -7940.12232324823, 7.82248472028153, -58.6544326902468, 3550.73647696481, -1.15303107290162E-04,
                       -1.75092403171802, 257.98168774816, -727.048374179467, 1.21644822609198E-04,
                       3.93137871762692E-02, 7.04181005909296E-03, -82.910820069811, -0.26517881813125,
                       13.7531682453991, -52.2394090753046, 2405.56298941048, -22736.1631268929,
                       89074.6343932567, -23923456.5822486, 5687958081.29714])
        sigma = s / 5.3
        eta = h / 2800
        pi = 0
        for i in range(0, 35):
            pi += ni[i] * (eta - 0.681) ** ii[i] * (sigma - 0.792) ** ji[i]

        return 16.6 / pi


@jit(float64(float64), cache=True, nopython=True)
def p3sat_h(h):
    # Revised Supplementary Release on Backward Equations for the
    # functions T(p,h), v(p,h)  and T(p,s), v(p,s) for region 3 of
    # the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water  and Steam
    # 2004
    # Section 4 Boundary Equations psat(h)  and psat(s) for the Saturation Lines of region 3
    # Se pictures Page 17, Eq 10, Table 17, Page 18
    ii = np.array([0, 1, 1, 1, 1, 5, 7, 8, 14, 20, 22, 24, 28, 36])
    ji = np.array([0, 1, 3, 4, 36, 3, 0, 24, 16, 16, 3, 18, 8, 24])
    ni = np.array([0.600073641753024, -9.36203654849857, 24.6590798594147,
                   -107.014222858224, -91582131580576.8, -8623.32011700662,
                   -23.5837344740032, 2.52304969384128E+17, -3.89718771997719E+18, -3.33775713645296E+22,
                   35649946963.6328, -1.48547544720641E+26, 3.30611514838798E+18, 8.13641294467829E+37])
    hs = h / 2600
    ps = 0
    for i in range(0, 14):
        ps += ni[i] * (hs - 1.02) ** ii[i] * (hs - 0.608) ** ji[i]

    return ps * 22


@jit(float64(float64), cache=True, nopython=True)
def h4l_p(p):
    # ts = 0
    hs = 0
    if 0.000611657 < p < 22.06395:
        ts = t4_p(p)
        if p < 16.529:
            return h1_pt(p, ts)
        else:
            # Iterate to find the the backward solution of p3sat_h
            low_bound = 1670.858218
            high_bound = 2087.23500164864
            ps = -1000
            while abs(p - ps) > 0.00001:
                hs = (low_bound + high_bound) / 2
                ps = p3sat_h(hs)
                if ps > p:
                    high_bound = hs
                else:
                    low_bound = hs

            return hs

    else:
        return math.nan


@jit(float64(float64), cache=True, nopython=True)
def h4v_p(p):
    hs = 0
    if 0.000611657 < p < 22.06395:
        ts = t4_p(p)
        if p < 16.529:
            return h2_pt(p, ts)
        else:
            # Iterate to find the the backward solution of p3sat_h
            low_bound = 2087.23500164864
            high_bound = 2563.592004 + 5
            ps = -1000
            while abs(p - ps) > 0.000001:
                hs = (low_bound + high_bound) / 2
                ps = p3sat_h(hs)
                if ps < p:
                    high_bound = hs
                else:
                    low_bound = hs

            return hs
    else:
        return math.nan


@jit(float64(float64, float64), cache=True, nopython=True)
def h3_pt(p, t):
    # Not available with if 97
    # Solve def t3_ph-T=0 with half interval method.
    # ver2.6 Start corrected bug
    ts = 0.0
    if p < 22.06395:  # Below triple point
        ts = t4_p(p)  # Saturation temperature
        if t <= ts:  # Liquid side
            high_bound = h4l_p(p)  # Max h r liauid h.
            low_bound = h1_pt(p, 623.15)
        else:
            low_bound = h4v_p(p)  # Min h r Vapour h.
            high_bound = h2_pt(p, b23t_p(p))

    else:  # Above triple point. R3 from R2 till R3.
        low_bound = h1_pt(p, 623.15)
        high_bound = h2_pt(p, b23t_p(p))

    # ver2.6 End corrected bug
    ts = t + 1
    hs = 0
    while abs(t - ts) > 0.00001:
        hs = (low_bound + high_bound) / 2
        ts = t3_ph(p, hs)
        if ts > t:
            high_bound = hs
        else:
            low_bound = hs

    return hs


@jit(float64(float64, float64), cache=True, nopython=True)
def t3_prho(p, rho):
    # Solve by iteration. Observe that fo low temperatures this equation has 2 solutions.
    # Solve with half interval method
    low_bound = 623.15
    high_bound = 1073.15
    ps = -1000
    ts = 0
    while abs(p - ps) > 0.00000001:
        ts = (low_bound + high_bound) / 2
        ps = p3_rhot(rho, ts)
        if ps > p:
            high_bound = ts
        else:
            low_bound = ts

    return ts


# ***********************************************************************************************************
# *2.4 functions for region 4
@jit(float64(float64), cache=True, nopython=True)
def p4_t(t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Section 8.1 The Saturation-Pressure Equation
    # Eq 30, Page 33
    teta = t - 0.23855557567849 / (t - 650.17534844798)
    a = teta ** 2 + 1167.0521452767 * teta - 724213.16703206
    b = -17.073846940092 * teta ** 2 + 12020.82470247 * teta - 3232555.0322333
    c = 14.91510861353 * teta ** 2 - 4823.2657361591 * teta + 405113.40542057
    return (2 * c / (-b + (b ** 2 - 4 * a * c) ** 0.5)) ** 4


@jit(float64(float64), cache=True, nopython=True)
def h4_s(s):
    # Supplementary Release on Backward Equations ( ) , p h s for
    # region 3,Equations as a def of h and s for the region Boundaries,
    # and an Equation( ) sat , T hs for region 4 of
    # the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # 4 Equations for region Boundaries Given Enthalpy and Entropy
    # Se picture page 14
    if -0.0001545495919 < s <= 3.77828134:
        # hL1_s
        # Eq 3,Table 9,Page 16
        ii = np.array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 7, 8, 12, 12, 14, 14, 16, 20, 20, 22, 24, 28, 32, 32])
        ji = np.array([14, 36, 3, 16, 0, 5, 4, 36, 4, 16, 24, 18, 24, 1, 4, 2, 4, 1, 22, 10, 12, 28, 8, 3, 0, 6, 8])
        ni = np.array([0.332171191705237, 6.11217706323496E-04, -8.82092478906822, -0.45562819254325,
                       -2.63483840850452E-05, -22.3949661148062, -4.28398660164013, -0.616679338856916,
                       -14.682303110404, 284.523138727299, -113.398503195444, 1156.71380760859,
                       395.551267359325, -1.54891257229285, 19.4486637751291, -3.57915139457043,
                       -3.35369414148819, -0.66442679633246, 32332.1885383934, 3317.66744667084,
                       -22350.1257931087, 5739538.75852936, 173.226193407919, -3.63968822121321E-02,
                       8.34596332878346E-07, 5.03611916682674, 65.5444787064505])
        sigma = s / 3.8
        eta = 0
        for i in range(0, 27):
            eta += ni[i] * (sigma - 1.09) ** ii[i] * (sigma + 0.0000366) ** ji[i]

        return eta * 1700
    elif 3.77828134 < s <= 4.41202148223476:
        # hL3_s
        # Eq 4,Table 10,Page 16
        ii = np.array([0, 0, 0, 0, 2, 3, 4, 4, 5, 5, 6, 7, 7, 7, 10, 10, 10, 32, 32])
        ji = np.array([1, 4, 10, 16, 1, 36, 3, 16, 20, 36, 4, 2, 28, 32, 14, 32, 36, 0, 6])
        ni = np.array([0.822673364673336, 0.181977213534479, -0.011200026031362, -7.46778287048033E-04,
                       -0.179046263257381, 4.24220110836657E-02, -0.341355823438768, -2.09881740853565,
                       -8.22477343323596, -4.99684082076008, 0.191413958471069, 5.81062241093136E-02,
                       -1655.05498701029, 1588.70443421201, -85.0623535172818, -31771.4386511207,
                       -94589.0406632871, -1.3927384708869E-06, 0.63105253224098])
        sigma = s / 3.8
        eta = 0
        for i in range(0, 19):
            eta += ni[i] * (sigma - 1.09) ** ii[i] * (sigma + 0.0000366) ** ji[i]

        return eta * 1700
    elif 4.41202148223476 < s <= 5.85:
        # Section 4.4 Equations ( ) 2ab " h s and ( ) 2c3b "h s for the Saturated Vapor Line
        # Page 19, Eq 5
        # hV2c3b_s(s)
        ii = np.array([0, 0, 0, 1, 1, 5, 6, 7, 8, 8, 12, 16, 22, 22, 24, 36])
        ji = np.array([0, 3, 4, 0, 12, 36, 12, 16, 2, 20, 32, 36, 2, 32, 7, 20])
        ni = np.array([1.04351280732769, -2.27807912708513, 1.80535256723202,
                       0.420440834792042, -105721.24483466, 4.36911607493884E+24,
                       -328032702839.753, -6.7868676080427E+15, 7439.57464645363, -3.56896445355761E+19,
                       1.67590585186801E+31, -3.55028625419105E+37, 396611982166.538, -4.14716268484468E+40,
                       3.59080103867382E+18, -1.16994334851995E+40])
        sigma = s / 5.9
        eta = 0
        for i in range(0, 16):
            eta += ni[i] * (sigma - 1.02) ** ii[i] * (sigma - 0.726) ** ji[i]

        return eta ** 4 * 2800
    elif 5.85 < s < 9.155759395:
        # Section 4.4 Equations ( ) 2ab " h s and ( ) 2c3b "h s for the Saturated Vapor Line
        # Page 20, Eq 6
        ii = np.array([1, 1, 2, 2, 4, 4, 7, 8, 8, 10, 12, 12, 18, 20, 24,
                       28, 28, 28, 28, 28, 32, 32, 32, 32, 32, 36, 36, 36, 36, 36])
        ji = np.array([8, 24, 4, 32, 1, 2, 7, 5, 12, 1, 0, 7, 10, 12, 32, 8,
                       12, 20, 22, 24, 2, 7, 12, 14, 24, 10, 12, 20, 22, 28])
        ni = np.array([-524.581170928788, -9269472.18142218, -237.385107491666, 21077015581.2776, -23.9494562010986,
                       221.802480294197, -5104725.33393438, 1249813.96109147, 2000084369.96201, -815.158509791035,
                       -157.612685637523, -11420042233.2791, 6.62364680776872E+15, -2.27622818296144E+18,
                       -1.71048081348406E+31, 6.60788766938091E+15, 1.66320055886021E+22, -2.18003784381501E+29,
                       -7.87276140295618E+29, 1.51062329700346E+31, 7957321.70300541, 1.31957647355347E+15,
                       -3.2509706829914E+23, -4.18600611419248E+25, 2.97478906557467E+34, -9.53588761745473E+19,
                       1.66957699620939E+24, -1.75407764869978E+32, 3.47581490626396E+34, -7.10971318427851E+38])
        sigma1 = s / 5.21
        sigma2 = s / 9.2
        eta = 0
        for i in range(0, 30):
            eta += ni[i] * (1 / sigma1 - 0.513) ** ii[i] * (sigma2 - 0.524) ** ji[i]

        return math.exp(eta) * 2800

    # else:
    #     return None
    return math.nan


@jit(float64(float64), cache=True, nopython=True)
def p4_s(s):
    # Uses h4_s and p_hs for the different regions to determine p4_s
    h_sat = h4_s(s)
    if -0.0001545495919 < s <= 3.77828134:
        return p1_hs(h_sat, s)
    elif 3.77828134 < s <= 5.210887663:
        return p3_hs(h_sat, s)
    elif 5.210887663 < s < 9.155759395:
        return p2_hs(h_sat, s)
    else:
        return math.nan


@jit(float64(float64, float64), cache=True, nopython=True)
def x4_ph(p, h):
    # Calculate vapour fraction from hL and hV for given p
    h4v = h4v_p(p)
    h4l = h4l_p(p)
    if h > h4v:
        return 1
    elif h < h4l:
        return 0
    else:
        return (h - h4l) / (h4v - h4l)


@jit(float64(float64, float64), cache=True, nopython=True)
def x4_ps(p, s):
    if p < 16.529:
        ssv = s2_pt(p, t4_p(p))
        ssl = s1_pt(p, t4_p(p))
    else:
        ssv = s3_rhot(1 / (v3_ph(p, h4v_p(p))), t4_p(p))
        ssl = s3_rhot(1 / (v3_ph(p, h4l_p(p))), t4_p(p))

    if s < ssl:
        return 0
    elif s > ssv:
        return 1
    else:
        return (s - ssl) / (ssv - ssl)


@jit(float64(float64, float64), cache=True, nopython=True)
def t4_hs(h, s):
    # Supplementary Release on Backward Equations ( ) , p h s for region 3,
    # Chapter 5.3 page 30.
    # The if 97 def is only valid for part of region4. Use iteration outside.
    pl = 0
    p = 0
    ii = np.array([0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3,
                   3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 8, 10, 10,
                   12, 14, 14, 16, 16, 18, 18, 18, 20, 28])
    ji = np.array([0, 3, 12, 0, 1, 2, 5, 0, 5, 8, 0, 2, 3, 4,
                   0, 1, 1, 2, 4, 16, 6, 8, 22, 1, 20, 36, 24,
                   1, 28, 12, 32, 14, 22, 36, 24, 36])
    ni = np.array([0.179882673606601, -0.267507455199603, 1.162767226126, 0.147545428713616, -0.512871635973248,
                   0.421333567697984, 0.56374952218987, 0.429274443819153, -3.3570455214214, 10.8890916499278,
                   -0.248483390456012, 0.30415322190639, -0.494819763939905, 1.07551674933261, 7.33888415457688E-02,
                   1.40170545411085E-02, -0.106110975998808, 1.68324361811875E-02, 1.25028363714877, 1013.16840309509,
                   -1.51791558000712, 52.4277865990866, 23049.5545563912, 2.49459806365456E-02, 2107964.67412137,
                   366836848.613065, -144814105.365163, -1.7927637300359E-03, 4899556021.00459, 471.262212070518,
                   -82929439019.8652, -1715.45662263191, 3557776.82973575, 586062760258.436, -12988763.5078195,
                   31724744937.1057])

    if 5.210887825 < s < 9.15546555571324:
        sigma = s / 9.2
        eta = h / 2800
        teta = 0
        for i in range(0, 36):
            teta += ni[i] * (eta - 0.119) ** ii[i] * (sigma - 1.07) ** ji[i]

        return teta * 550
    else:
        # def psat_h
        if -0.0001545495919 < s <= 3.77828134:
            low_bound = 0.000611
            high_bound = 165.291642526045
            hl = -1000
            while abs(hl - h) > 0.00001 and abs(high_bound - low_bound) > 0.0001:
                pl = (low_bound + high_bound) / 2
                ts = t4_p(pl)
                hl = h1_pt(pl, ts)
                if hl > h:
                    high_bound = pl
                else:
                    low_bound = pl

        elif 3.77828134 < s <= 4.41202148223476:
            pl = p3sat_h(h)
        elif 4.41202148223476 < s <= 5.210887663:
            pl = p3sat_h(h)

        low_bound = 0.000611
        high_bound = pl
        sss = -1000
        while abs(s - sss) > 0.000001 and abs(high_bound - low_bound) > 0.0000001:
            p = (low_bound + high_bound) / 2
            # Calculate s4_ph
            ts = t4_p(p)
            xs = x4_ph(p, h)
            if p < 16.529:
                s4v = s2_pt(p, ts)
                s4l = s1_pt(p, ts)
            else:
                v4v = v3_ph(p, h4v_p(p))
                s4v = s3_rhot(1 / v4v, ts)
                v4l = v3_ph(p, h4l_p(p))
                s4l = s3_rhot(1 / v4l, ts)

            sss = (xs * s4v + (1 - xs) * s4l)

            if sss < s:
                high_bound = p
            else:
                low_bound = p

        return t4_p(p)

    return math.nan


# ***********************************************************************************************************
# *2.5 functions for region 5
@jit(float64(float64, float64), cache=True, nopython=True)
def h5_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for the
    # Thermodynamic Properties of Water and Steam, September 1997
    # Basic Equation for region 5
    # Eq 32,33, Page 36, Tables 37-41
    ji0 = np.array([0, 1, -3, -2, -1, 2])
    ni0 = np.array([-13.179983674201, 6.8540841634434, -0.024805148933466,
                    0.36901534980333, -3.1161318213925, -0.32961626538917])
    iir = np.array([1, 1, 1, 2, 3])
    jir = np.array([0, 1, 3, 9, 3])
    nir = np.array([-1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991,
                    -3.9724828359569E-06, 1.2919228289784E-07])
    # kJ/(kg K)
    tau = 1000 / t
    pi = p
    gamma0_tau = 0
    for i in range(0, 6):
        gamma0_tau += ni0[i] * ji0[i] * tau ** (ji0[i] - 1)

    gammar_tau = 0
    for i in range(0, 5):
        gammar_tau += nir[i] * pi ** iir[i] * jir[i] * tau ** (jir[i] - 1)

    return __R * t * tau * (gamma0_tau + gammar_tau)


@jit(float64(float64, float64), cache=True, nopython=True)
def v5_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Basic Equation for region 5
    # Eq 32,33, Page 36, Tables 37-41
    # Ji0 = [0, 1, -3, -2, -1, 2]
    # ni0 = [-13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333,
    # -3.1161318213925, -0.32961626538917]
    iir = np.array([1, 1, 1, 2, 3])
    jir = np.array([0, 1, 3, 9, 3])
    nir = np.array([-1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991,
                    -3.9724828359569E-06, 1.2919228289784E-07])
    # kJ/(kg K)
    tau = 1000 / t
    pi = p
    gamma0_pi = 1 / pi
    gammar_pi = 0
    for i in range(0, 5):
        gammar_pi += nir[i] * iir[i] * pi ** (iir[i] - 1) * tau ** jir[i]

    return __R * t / p * pi * (gamma0_pi + gammar_pi) / 1000


@jit(float64(float64, float64), cache=True, nopython=True)
def u5_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Basic Equation for region 5
    # Eq 32,33, Page 36, Tables 37-41
    ji0 = np.array([0, 1, -3, -2, -1, 2])
    ni0 = np.array([-13.179983674201, 6.8540841634434, -0.024805148933466,
                    0.36901534980333, -3.1161318213925, -0.32961626538917])
    iir = np.array([1, 1, 1, 2, 3])
    jir = np.array([0, 1, 3, 9, 3])
    nir = np.array([-1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991,
                    -3.9724828359569E-06, 1.2919228289784E-07])
    # kJ/(kg K)
    tau = 1000 / t
    pi = p
    gamma0_pi = 1 / pi
    gamma0_tau = 0
    for i in range(0, 6):
        gamma0_tau += ni0[i] * ji0[i] * tau ** (ji0[i] - 1)

    gammar_pi = 0
    gammar_tau = 0
    for i in range(0, 5):
        gammar_pi += nir[i] * iir[i] * pi ** (iir[i] - 1) * tau ** jir[i]
        gammar_tau += nir[i] * pi ** iir[i] * jir[i] * tau ** (jir[i] - 1)

    return __R * t * (tau * (gamma0_tau + gammar_tau) - pi * (gamma0_pi + gammar_pi))


@jit(float64(float64, float64), cache=True, nopython=True)
def cp5_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Basic Equation for region 5
    # Eq 32,33, Page 36, Tables 37-41
    ji0 = np.array([0, 1, -3, -2, -1, 2])
    ni0 = np.array([-13.179983674201, 6.8540841634434, -0.024805148933466,
                    0.36901534980333, -3.1161318213925, -0.32961626538917])
    iir = np.array([1, 1, 1, 2, 3])
    jir = np.array([0, 1, 3, 9, 3])
    nir = np.array([-1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991,
                    -3.9724828359569E-06, 1.2919228289784E-07])
    # kJ/(kg K)
    tau = 1000 / t
    pi = p
    gamma0_tautau = 0
    for i in range(0, 6):
        gamma0_tautau += ni0[i] * ji0[i] * (ji0[i] - 1) * tau ** (ji0[i] - 2)

    gammar_tautau = 0
    for i in range(0, 5):
        gammar_tautau += nir[i] * pi ** iir[i] * jir[i] * (jir[i] - 1) * tau ** (jir[i] - 2)

    return -__R * tau ** 2 * (gamma0_tautau + gammar_tautau)


@jit(float64(float64, float64), cache=True, nopython=True)
def s5_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Basic Equation for region 5
    # Eq 32,33, Page 36, Tables 37-41
    ji0 = np.array([0, 1, -3, -2, -1, 2])
    ni0 = np.array([-13.179983674201, 6.8540841634434, -0.024805148933466,
                    0.36901534980333, -3.1161318213925, -0.32961626538917])
    iir = np.array([1, 1, 1, 2, 3])
    jir = np.array([0, 1, 3, 9, 3])
    nir = np.array([-1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991,
                    -3.9724828359569E-06, 1.2919228289784E-07])
    # kJ/(kg K)
    tau = 1000 / t
    pi = p
    gamma0 = math.log(pi)
    gamma0_tau = 0
    for i in range(0, 6):
        gamma0_tau += ni0[i] * ji0[i] * tau ** (ji0[i] - 1)
        gamma0 += ni0[i] * tau ** ji0[i]

    gammar = 0
    gammar_tau = 0
    for i in range(0, 5):
        gammar += nir[i] * pi ** iir[i] * tau ** jir[i]
        gammar_tau += nir[i] * pi ** iir[i] * jir[i] * tau ** (jir[i] - 1)

    return __R * (tau * (gamma0_tau + gammar_tau) - (gamma0 + gammar))


@jit(float64(float64, float64), cache=True, nopython=True)
def cv5_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Basic Equation for region 5
    # Eq 32,33, Page 36, Tables 37-41
    ji0 = np.array([0, 1, -3, -2, -1, 2])
    ni0 = np.array([-13.179983674201, 6.8540841634434, -0.024805148933466,
                    0.36901534980333, -3.1161318213925, -0.32961626538917])
    iir = np.array([1, 1, 1, 2, 3])
    jir = np.array([0, 1, 3, 9, 3])
    nir = np.array([-1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991,
                    -3.9724828359569E-06, 1.2919228289784E-07])
    # kJ/(kg K)
    tau = 1000 / t
    pi = p
    gamma0_tautau = 0
    for i in range(0, 6):
        gamma0_tautau += ni0[i] * (ji0[i] - 1) * ji0[i] * tau ** (ji0[i] - 2)

    gammar_pi = 0
    gammar_pitau = 0
    gammar_pipi = 0
    gammar_tautau = 0
    for i in range(0, 5):
        gammar_pi += nir[i] * iir[i] * pi ** (iir[i] - 1) * tau ** jir[i]
        gammar_pitau += nir[i] * iir[i] * pi ** (iir[i] - 1) * jir[i] * tau ** (jir[i] - 1)
        gammar_pipi += nir[i] * iir[i] * (iir[i] - 1) * pi ** (iir[i] - 2) * tau ** jir[i]
        gammar_tautau += nir[i] * pi ** iir[i] * jir[i] * (jir[i] - 1) * tau ** (jir[i] - 2)

    return __R * (-(tau ** 2 * (gamma0_tautau + gammar_tautau)) - (1 + pi * gammar_pi - tau * pi * gammar_pitau) ** 2 /
                  (1 - pi ** 2 * gammar_pipi))


@jit(float64(float64, float64), cache=True, nopython=True)
def w5_pt(p, t):
    # Release on the IAPWS Industrial formulation 1997 for
    # the Thermodynamic Properties of Water and Steam, September 1997
    # Basic Equation for region 5
    # Eq 32,33, Page 36, Tables 37-41
    ji0 = np.array([0, 1, -3, -2, -1, 2])
    ni0 = np.array([-13.179983674201, 6.8540841634434, -0.024805148933466,
                    0.36901534980333, -3.1161318213925, -0.32961626538917])
    iir = np.array([1, 1, 1, 2, 3])
    jir = np.array([0, 1, 3, 9, 3])
    nir = np.array([-1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991,
                    -3.9724828359569E-06, 1.2919228289784E-07])
    # kJ/(kg K)
    tau = 1000 / t
    pi = p
    gamma0_tautau = 0
    for i in range(0, 6):
        gamma0_tautau += ni0[i] * (ji0[i] - 1) * ji0[i] * tau ** (ji0[i] - 2)

    gammar_pi = 0
    gammar_pitau = 0
    gammar_pipi = 0
    gammar_tautau = 0
    for i in range(0, 5):
        gammar_pi += nir[i] * iir[i] * pi ** (iir[i] - 1) * tau ** jir[i]
        gammar_pitau += nir[i] * iir[i] * pi ** (iir[i] - 1) * jir[i] * tau ** (jir[i] - 1)
        gammar_pipi += nir[i] * iir[i] * (iir[i] - 1) * pi ** (iir[i] - 2) * tau ** jir[i]
        gammar_tautau += nir[i] * pi ** iir[i] * jir[i] * (jir[i] - 1) * tau ** (jir[i] - 2)

    return (1000 * __R * t * (1 + 2 * pi * gammar_pi + pi ** 2 * gammar_pi ** 2) / (
        (1 - pi ** 2 * gammar_pipi) + (1 + pi * gammar_pi - tau * pi * gammar_pitau) ** 2 / (
        tau ** 2 * (gamma0_tautau + gammar_tautau)))) ** 0.5


@jit(float64(float64, float64), cache=True, nopython=True)
def t5_ph(p, h):
    # Solve with half interval method
    low_bound = 1073.15
    high_bound = 2273.15
    hs = h - 1
    ts = 0

    while abs(h - hs) > 0.00001:
        ts = (low_bound + high_bound) / 2
        hs = h5_pt(p, ts)
        if hs > h:
            high_bound = ts
        else:
            low_bound = ts

    return ts


@jit(float64(float64, float64), cache=True, nopython=True)
def t5_ps(p, s):
    # Solve with half interval method
    low_bound = 1073.15
    high_bound = 2273.15
    ss = s - 1
    ts = 0
    while abs(s - ss) > 0.00001:
        ts = (low_bound + high_bound) / 2
        ss = s5_pt(p, ts)
        if ss > s:
            high_bound = ts
        else:
            low_bound = ts

    return ts


@jit(float64(float64, float64), cache=True, nopython=True)
def t5_prho(p, rho):
    # Solve by iteration. Observe that fo low temperatures this equation has 2 solutions.
    # Solve with half interval method

    low_bound = 1073.15
    high_bound = 2073.15
    rhos = -1000
    ts = 0
    while abs(rho - rhos) > 0.000001:
        ts = (low_bound + high_bound) / 2
        rhos = 1 / v2_pt(p, ts)
        if rhos < rho:
            high_bound = ts
        else:
            low_bound = ts

    return ts


# ***********************************************************************************************************
# *3 region Selection
# ***********************************************************************************************************
# *3.1 Regions as a def of pT

@jit(float64(float64), cache=True, nopython=True)
def b23p_t(t):
    # Release on the IAPWS Industrial formulation 1997 for the Thermodynamic Properties of Water and Steam
    # 1997
    # Section 4 Auxiliary Equation for the Boundary between Regions 2 and 3
    # Eq 5, Page 5
    return 348.05185628969 - 1.1671859879975 * t + 1.0192970039326E-03 * t ** 2


@jit(int64(float64, float64), cache=True, nopython=True)
def region_pt(p, t):
    if 1073.15 < t < 2273.15 and 10 > p > 0.000611:
        return 5
    elif 1073.15 >= t > 273.15 and 100 >= p > 0.000611:
        if t > 623.15:
            if p > b23p_t(t):
                # region_pt = 3
                if t < 647.096:
                    ps = p4_t(t)
                    if abs(p - ps) < 0.00001:
                        return 4
                else:
                    return 3
            else:
                return 2
        else:
            ps = p4_t(t)
            if abs(p - ps) < 0.00001:
                return 4
            elif p > ps:
                return 1
            else:
                return 2
    else:
        return 0  # **Error, Outside valid area

    return 0


# ***********************************************************************************************************
# *3.2 Regions as a def of ph


# ***********************************************************************************************************
# *3.3 Regions as a def of ps

# ***********************************************************************************************************
# *3.4 Regions as a def of hs

@jit(float64(float64), cache=True, nopython=True)
def hb13_s(s):
    # Supplementary Release on Backward Equations ( ) , p h s for region 3,
    # Chapter 4.5 page 23.
    ii = np.array([0, 1, 1, 3, 5, 6])
    ji = np.array([0, -2, 2, -12, -4, -3])
    ni = np.array([0.913965547600543, -4.30944856041991E-05, 60.3235694765419,
                   1.17518273082168E-18, 0.220000904781292, -69.0815545851641])
    sigma = s / 3.8
    eta = 0
    for i in range(0, 6):
        eta += ni[i] * (sigma - 0.884) ** ii[i] * (sigma - 0.864) ** ji[i]

    return eta * 1700


@jit(float64(float64, float64), cache=True, nopython=True)
def tb23_hs(h, s):
    # Supplementary Release on Backward Equations ( ) , p h s for region 3,
    # Chapter 4.6 page 25.
    ii = np.array([-12, -10, -8, -4, -3, -2, -2, -2, -2, 0, 1, 1, 1, 3, 3, 5, 6, 6, 8, 8, 8, 12, 12, 14, 14])
    ji = np.array([10, 8, 3, 4, 3, -6, 2, 3, 4, 0, -3, -2, 10, -2, -1, -5, -6, -3, -8, -2, -1, -12, -1, -12, 1])
    ni = np.array([6.2909626082981E-04, -8.23453502583165E-04, 5.15446951519474E-08, -1.17565945784945,
                   3.48519684726192, -5.07837382408313E-12, -2.84637670005479, -2.36092263939673, 6.01492324973779,
                   1.48039650824546, 3.60075182221907E-04, -1.26700045009952E-02, -1221843.32521413, 0.149276502463272,
                   0.698733471798484, -2.52207040114321E-02, 1.47151930985213E-02, -1.08618917681849,
                   -9.36875039816322E-04, 81.9877897570217, -182.041861521835, 2.61907376402688E-06,
                   -29162.6417025961, 1.40660774926165E-05, 7832370.62349385])
    sigma = s / 5.3
    eta = h / 3000
    teta = 0
    for i in range(0, 25):
        teta += ni[i] * (eta - 0.727) ** ii[i] * (sigma - 0.864) ** ji[i]

    return teta * 900


@jit(int64(float64, float64), cache=True, nopython=True)
def region_hs(h, s):
    if s < -0.0001545495919:
        return 0

    # Check linear adaption to p=0.000611. if bellow region 4.
    hmin = (((-0.0415878 - 2500.89262) / (-0.00015455 - 9.155759)) * s)
    if s < 9.155759395 and h < hmin:
        return 0

    # ******Kolla 1 eller 4. (+liten bit ver B13)
    if -0.0001545495919 <= s <= 3.77828134:
        if h < h4_s(s):
            return 4
        elif s < 3.397782955:  # 100MPa line is limiting
            tmax = t1_ps(100, s)
            hmax = h1_pt(100, tmax)
            if h < hmax:
                return 1
            else:
                return 0

        else:  # The point is either in region 4,1,3. Check B23
            hb = hb13_s(s)
            if h < hb:
                return 1

            tmax = t3_ps(100, s)
            vmax = v3_ps(100, s)
            hmax = h3_rhot(1 / vmax, tmax)
            if h < hmax:
                return 3
            else:
                return 0

    # ******Kolla region 2 eller 4. (vre delen av omrde b23-> max)
    if 5.260578707 <= s <= 11.9212156897728:
        if s > 9.155759395:  # Above region 4
            tmin = t2_ps(0.000611, s)
            hmin = h2_pt(0.000611, tmin)
            # def adapted to h(1073.15,s)
            hmax = -0.07554022 * s ** 4 + 3.341571 * s ** 3 - 55.42151 * s ** 2 + 408.515 * s + 3031.338
            if hmin < h < hmax:
                return 2
            else:
                return 0

        hv = h4_s(s)
        if h < hv:  # region 4. Under region 3.
            return 4

        if s < 6.04048367171238:
            tmax = t2_ps(100, s)
            hmax = h2_pt(100, tmax)
        else:
            # def adapted to h(1073.15,s)
            hmax = -2.988734 * s ** 4 + 121.4015 * s ** 3 - 1805.15 * s ** 2 + 11720.16 * s - 23998.33

        if h < hmax:  # region 2. ver region 4.
            return 2
        else:
            return 0

    # Kolla region 3 eller 4. Under kritiska punkten.
    if 3.77828134 <= s <= 4.41202148223476:
        hl = h4_s(s)
        if h < hl:
            return 4

        tmax = t3_ps(100, s)
        vmax = v3_ps(100, s)
        hmax = h3_rhot(1 / vmax, tmax)
        if h < hmax:
            return 3
        else:
            return 0

    # Kolla region 3 eller 4 frn kritiska punkten till vre delen av b23
    if 4.41202148223476 <= s <= 5.260578707:
        hv = h4_s(s)
        if h < hv:
            return 4

        # Kolla om vi r under b23 giltighetsomrde.
        if s <= 5.048096828:
            tmax = t3_ps(100, s)
            vmax = v3_ps(100, s)
            hmax = h3_rhot(1 / vmax, tmax)
            if h < hmax:
                return 3
            else:
                return 0

        else:  # Inom omrdet fr B23 i s led.
            if h > 2812.942061:  # Ovanfr B23 i h_led
                if s > 5.09796573397125:
                    tmax = t2_ps(100, s)
                    hmax = h2_pt(100, tmax)
                    if h < hmax:
                        return 2
                    else:
                        return 0
                else:
                    return 0

            if h < 2563.592004:  # Nedanfr B23 i h_led men vi har redan kollat ovanfr hV2c3b
                return 3

            # Vi r inom b23 omrdet i bde s och h led.
            tact = tb23_hs(h, s)
            pact = p2_hs(h, s)
            pbound = b23p_t(tact)
            if pact > pbound:
                return 3
            else:
                return 2

    return 0


# ***********************************************************************************************************
# *3.5 Regions as a def of p and rho
@jit(int64(float64, float64), cache=True, nopython=True)
def region_prho(p, rho):
    v = 1 / rho
    if p < 0.000611657 or p > 100:
        # region_prho = 0
        return 0

    if p < 16.5292:  # Bellow region 3, Check region 1,4,2
        if v < v1_pt(p, 273.15):  # Observe that this is not actually min of v. Not valid Water of 4C is lighter.
            return 0

        if v <= v1_pt(p, t4_p(p)):
            return 1

        if v < v2_pt(p, t4_p(p)):
            return 4

        if v <= v2_pt(p, 1073.15):
            return 2

        if p > 10:  # Above region 5
            return 0

        if v <= v5_pt(p, 2073.15):
            return 5

    else:  # Check region 1,3,4,3,2 (Above the lowest point of region 3.)
        if v < v1_pt(p, 273.15):  # Observe that this is not actually min of v. Not valid Water of 4C is lighter.
            return 0

        if v < v1_pt(p, 623.15):
            return 1

        # Check if in region 3 or 4 (Bellow Reg 2)
        if v < v2_pt(p, b23t_p(p)):
            # region 3 or 4
            if p > 22.064:  # Above region 4
                return 3

            if v < v3_ph(p, h4l_p(p)) or v > v3_ph(p, h4v_p(p)):  # Uses iteration!!
                return 3
            else:
                return 4

        # Check if region 2
        if v < v2_pt(p, 1073.15):
            return 2

    return 0


# ***********************************************************************************************************
# *4 region Borders
# ***********************************************************************************************************
# ***********************************************************************************************************
# *4.1 Boundary between region 2 and 3.


# ***********************************************************************************************************
# *4.2 region 3. pSat_h  and pSat_s
@jit(float64(float64), cache=True, nopython=True)
def p3sat_s(s):
    ii = np.array([0, 1, 1, 4, 12, 12, 16, 24, 28, 32])
    ji = np.array([0, 1, 32, 7, 4, 14, 36, 10, 0, 18])
    ni = np.array([0.639767553612785, -12.9727445396014, -2.24595125848403E+15,
                   1774667.41801846, 7170793495.71538, -3.78829107169011E+17,
                   -9.55586736431328E+34, 1.87269814676188E+23, 119254746466.473,
                   1.10649277244882E+36])
    sigma = s / 5.2
    pi = 0
    for i in range(0, 10):
        pi += ni[i] * (sigma - 1.03) ** ii[i] * (sigma - 0.699) ** ji[i]

    return pi * 22


# ***********************************************************************************************************
# 4.3 region boundary 1to3  and 3to2 as a functions of s


# ***********************************************************************************************************
# *5 Transport properties
# ***********************************************************************************************************
# *5.1 Viscosity (IAPWS formulation 1985, Revised 2003)
# ***********************************************************************************************************
@jit(float64(float64, float64), cache=True, nopython=True)
def my_all_regions_pt(p, t):
    h0 = np.array([0.5132047, 0.3205656, 0, 0, -0.7782567, 0.1885447])
    h1 = np.array([0.2151778, 0.7317883, 1.241044, 1.476783, 0, 0])
    h2 = np.array([-0.2818107, -1.070786, -1.263184, 0, 0, 0])
    h3 = np.array([0.1778064, 0.460504, 0.2340379, -0.4924179, 0, 0])
    h4 = np.array([-0.0417661, 0, 0, 0.1600435, 0, 0])
    h5 = np.array([0, -0.01578386, 0, 0, 0, 0])
    h6 = np.array([0, 0, 0, -0.003629481, 0, 0])

    # Calculate density.
    reg = region_pt(p, t)
    if reg == 1:
        rho = 1 / v1_pt(p, t)
    elif reg == 2:
        rho = 1 / v2_pt(p, t)
    elif reg == 3:
        hs = h3_pt(p, t)
        rho = 1 / v3_ph(p, hs)
    elif reg == 4:
        rho = math.nan
    elif reg == 5:
        rho = 1 / v5_pt(p, t)
    else:
        # my_all_regions_pt = NaN
        return math.nan

    rhos = rho / 317.763
    ts = t / 647.226
    # ps = p / 22.115

    # Check valid area
    if t > 900 + 273.15 or (t > 600 + 273.15 and p > 300) or (t > 150 + 273.15 and p > 350) or p > 500:
        # my_all_regions_pt = NaN
        return math.nan

    my0 = ts ** 0.5 / (1 + 0.978197 / ts + 0.579829 / (ts ** 2) - 0.202354 / (ts ** 3))
    sum_temp = 0
    for i in range(0, 6):
        sum_temp += h0[i] * (1 / ts - 1) ** i
        sum_temp += h1[i] * (1 / ts - 1) ** i * (rhos - 1) ** 1
        sum_temp += h2[i] * (1 / ts - 1) ** i * (rhos - 1) ** 2
        sum_temp += h3[i] * (1 / ts - 1) ** i * (rhos - 1) ** 3
        sum_temp += h4[i] * (1 / ts - 1) ** i * (rhos - 1) ** 4
        sum_temp += h5[i] * (1 / ts - 1) ** i * (rhos - 1) ** 5
        sum_temp += h6[i] * (1 / ts - 1) ** i * (rhos - 1) ** 6

    my1 = math.exp(rhos * sum_temp)
    mys = my0 * my1
    return mys * 0.000055071


# ***********************************************************************************************************
# *5.2 Thermal Conductivity (IAPWS formulation 1985)
@jit(float64(float64, float64, float64), cache=True, nopython=True)
def tc_ptrho(p, t, rho):
    # Revised release on the IAPWS formulation 1985 for the Thermal Conductivity of ordinary water
    # IAPWS September 1998
    # Page 8
    # ver2.6 Start corrected bug
    if t < 273.15:
        # tc_ptrho = NaN #out of range of validity (para. B4)
        return math.nan
    elif t < 500 + 273.15:
        if p > 100:
            # tc_ptrho = NaN #out of range of validity (para. B4)
            return math.nan

    elif t <= 650 + 273.15:
        if p > 70:
            # tc_ptrho = NaN #out of range of validity (para. B4)
            return math.nan

    elif t <= 800 + 273.15:
        if p > 40:
            # tc_ptrho = NaN #out of range of validity (para. B4)
            return math.nan

    # ver2.6 End corrected bug
    t /= 647.26
    rho /= 317.7
    tc0 = t ** 0.5 * (0.0102811 + 0.0299621 * t + 0.0156146 * t ** 2 - 0.00422464 * t ** 3)
    tc1 = -0.39707 + 0.400302 * rho + 1.06 * math.exp(-0.171587 * (rho + 2.39219) ** 2)
    dt = abs(t - 1) + 0.00308976
    q = 2 + 0.0822994 / dt ** (3 / 5)
    if t >= 1:
        s = 1 / dt
    else:
        s = 10.0932 / dt ** (3 / 5)

    tc2 = (0.0701309 / t ** 10 + 0.011852) * rho ** (9 / 5) * math.exp(
        0.642857 * (1 - rho ** (14 / 5))) + 0.00169937 * s * rho ** q * math.exp(
        (q / (1 + q)) * (1 - rho ** (1 + q))) - 1.02 * math.exp(-4.11717 * t ** (3 / 2) - 6.17937 / rho ** 5)

    return tc0 + tc1 + tc2


# ***********************************************************************************************************
# 5.3 Surface Tension

@jit(float64(float64), cache=True, nopython=True)
def surface_tension_t(t):
    # IAPWS Release on Surface Tension of Ordinary Water Substance,
    # September 1994
    tc = 647.096  # K
    b = 0.2358  # N/m
    bb = -0.625
    my = 1.256
    if t < 0.01 or t > tc:
        # surface_tension_t = NaN #"out of valid region"
        return math.nan

    tau = 1 - t / tc
    return b * tau ** my * (1 + bb * tau)


@jit(int64(float64, float64), cache=True, nopython=True)
def region_ps(p, s):
    if p < 0.000611657 or p > 100 or s < 0 or s > s5_pt(p, 2273.15):
        return 0

    # Check region 5
    if s > s2_pt(p, 1073.15):
        if p <= 10:
            return 5
        else:
            return 0

    # Check region 2
    if p > 16.529:
        ss = s2_pt(p, b23t_p(p))  # Between 5.047  and 5.261. Use to speed up!
    else:
        ss = s2_pt(p, t4_p(p))

    if s > ss:
        return 2

    # Check region 3
    ss = s1_pt(p, 623.15)
    if p > 16.529 and s > ss:
        if p > p3sat_s(s):
            return 3
        else:
            return 4

    # Check region 4 (Not inside region 3)
    if p < 16.529 and s > s1_pt(p, t4_p(p)):
        return 4

    # Check region 1
    if p > 0.000611657 and s > s1_pt(p, 273.15):
        return 1

    return 1


@jit(int64(float64, float64), cache=True, nopython=True)
def region_ph(p, h):
    # Check if outside pressure limits
    if p < 0.000611657 or p > 100:
        return 0

    # Check if outside low h.
    if h < 0.963 * p + 2.2:  # Linear adaption to h1_pt()+2 to speed up calcualations.
        if h < h1_pt(p, 273.15):
            return 0

    if p < 16.5292:  # Bellow region 3,Check  region 1,4,2,5
        # Check region 1
        ts = t4_p(p)
        hl = 109.6635 * math.log(p) + 40.3481 * p + 734.58  # Approximate def for hL_p
        if abs(h - hl) < 100:  # if approximate is not god enough use real def
            hl = h1_pt(p, ts)

        if h <= hl:
            return 1

        # Check region 4
        hv = 45.1768 * math.log(p) - 20.158 * p + 2804.4  # Approximate def for hV_p
        if abs(h - hv) < 50:  # if approximate is not god enough use real def
            hv = h2_pt(p, ts)

        if h < hv:
            return 4

        # Check upper limit of region 2 Quick Test
        if h < 4000:
            return 2

        # Check region 2 (Real value)
        h_45 = h2_pt(p, 1073.15)
        if h <= h_45:
            return 2

        # Check region 5
        if p > 10:
            return 0

        h_5u = h5_pt(p, 2273.15)
        if h < h_5u:
            return 5

        return 0

    else:  # for p>16.5292
        # Check if in region1
        if h < h1_pt(p, 623.15):
            return 1

        # Check if in region 3 or 4 (Bellow Reg 2)
        if h < h2_pt(p, b23t_p(p)):
            # region 3 or 4
            if p > p3sat_h(h):
                return 3
            else:
                return 4

        # Check if region 2
        if h < h2_pt(p, 1073.15):
            return 2

    return 0


@jit(float64(float64, float64), cache=True, nopython=True)
def my_all_regions_ph(p, h):
    h0 = np.array([0.5132047, 0.3205656, 0, 0, -0.7782567, 0.1885447])
    h1 = np.array([0.2151778, 0.7317883, 1.241044, 1.476783, 0, 0])
    h2 = np.array([-0.2818107, -1.070786, -1.263184, 0, 0, 0])
    h3 = np.array([0.1778064, 0.460504, 0.2340379, -0.4924179, 0, 0])
    h4 = np.array([-0.0417661, 0, 0, 0.1600435, 0, 0])
    h5 = np.array([0, -0.01578386, 0, 0, 0, 0])
    h6 = np.array([0, 0, 0, -0.003629481, 0, 0])

    # Calculate density.
    reg = region_ph(p, h)

    if reg == 1:
        ts = t1_ph(p, h)
        t = ts
        rho = 1 / v1_pt(p, ts)
    elif reg == 2:
        ts = t2_ph(p, h)
        t = ts
        rho = 1 / v2_pt(p, ts)
    elif reg == 3:
        rho = 1 / v3_ph(p, h)
        t = t3_ph(p, h)
    elif reg == 4:
        xs = x4_ph(p, h)
        if p < 16.529:
            v4v = v2_pt(p, t4_p(p))
            v4l = v1_pt(p, t4_p(p))
        else:
            v4v = v3_ph(p, h4v_p(p))
            v4l = v3_ph(p, h4l_p(p))

        rho = 1 / (xs * v4v + (1 - xs) * v4l)
        t = t4_p(p)
    elif reg == 5:
        ts = t5_ph(p, h)
        t = ts
        rho = 1 / v5_pt(p, ts)
    else:
        # my_all_regions_ph = NaN
        return math.nan

    rhos = rho / 317.763
    ts = t / 647.226
    # ps = p / 22.115
    # Check valid area
    if (t > 900 + 273.15) or (t > 600 + 273.15 and p > 300) or (t > 150 + 273.15 and p > 350) or p > 500:
        # my_all_regions_ph = NaN
        return math.nan

    my0 = ts ** 0.5 / (1 + 0.978197 / ts + 0.579829 / (ts ** 2) - 0.202354 / (ts ** 3))

    sum_temp = 0
    for i in range(0, 6):
        sum_temp += h0[i] * (1 / ts - 1) ** i
        sum_temp += h1[i] * (1 / ts - 1) ** i * (rhos - 1) ** 1
        sum_temp += h2[i] * (1 / ts - 1) ** i * (rhos - 1) ** 2
        sum_temp += h3[i] * (1 / ts - 1) ** i * (rhos - 1) ** 3
        sum_temp += h4[i] * (1 / ts - 1) ** i * (rhos - 1) ** 4
        sum_temp += h5[i] * (1 / ts - 1) ** i * (rhos - 1) ** 5
        sum_temp += h6[i] * (1 / ts - 1) ** i * (rhos - 1) ** 6

    my1 = math.exp(rhos * sum_temp)
    mys = my0 * my1
    return mys * 0.000055071


# ***********************************************************************************************************
# * Water and steam properties according to IAPWS IF-97                                                     *
# * By Magnus Holmgren, www.x-eng.com                                                                       *
# * The steam tables are free and provided as is.                                                           *
# * We take no responsibilities for any errors in the code or damage thereby.                               *
# * You are free to use, modify and distribute the code as long as authorship is properly acknowledged.     *
# * Please notify me at magnus@x-eng.com if the code is used in commercial applications                     *
# ***********************************************************************************************************
#
# XSteam provides accurate steam and water properties from 0 - 1000 bar and from 0 - 2000 deg C according to
# the standard IAPWS IF-97. For accuracy of the functions in different regions see IF-97 (www.iapws.org)
#
# *** Using XSteam *****************************************************************************************
# XSteam take 2 or 3 arguments. The first argument must always be the steam table function you want to use.
# The other arguments are the inputs to that function.
# Example: XSteam('h_pt',1,20)  Returns the enthalpy of water at 1 bar and 20 degC
# Example: XSteam('TSat_p',1)  Returns the saturation temperature of water at 1 bar.
# For a list of valid Steam Table functions se bellow or the XSteam macros for MS Excel.
#
# *** Nomenclature ******************************************************************************************
# First the wanted property then a _ then the wanted input properties.
# Example. T_ph is temperature as a function of pressure and enthalpy.
# For a list of valid functions se bellow or XSteam for MS Excel.
# T     Temperature (deg C)
# p	    Pressure    (bar)
# h	    Enthalpy    (kJ/kg)
# v	    Specific volume (m3/kg)
# rho	Density
# s	    Specific entropy
# u	    Specific internal energy
# Cp	Specific isobaric heat capacity
# Cv	Specific isochoric heat capacity
# w	    Speed of sound
# my	Viscosity
# tc	Thermal Conductivity
# st	Surface Tension
# x	    Vapour fraction
# vx	Vapour Volume Fraction
#
# *** Valid Steam table functions. ****************************************************************************
#
# Temperature
# Tsat_p	Saturation temperature
# T_ph  Temperature as a function of pressure and enthalpy
# T_ps  Temperature as a function of pressure and entropy
# T_hs  Temperature as a function of enthalpy and entropy
#
# Pressure
# psat_T Saturation pressure
# p_hs	 Pressure as a function of h and s.
# p_hrho Pressure as a function of h and rho. Very inaccurate for solid water region
#        since it's almost incompressible!
#
# Enthalpy
# hV_p	 Saturated vapour enthalpy
# hL_p	 Saturated liquid enthalpy
# hV_T	 Saturated vapour enthalpy
# hL_T	 Saturated liquid enthalpy
# h_pT	 Enthalpy as a function of pressure and temperature.
# h_ps	 Enthalpy as a function of pressure and entropy.
# h_px	 Enthalpy as a function of pressure and vapour fraction
# h_prho Enthalpy as a function of pressure and density. Observe for low temperatures
#       (liquid) this equation has 2 solutions.
# h_Tx	 Enthalpy as a function of temperature and vapour fraction
#
# Specific volume
# vV_p	Saturated vapour volume
# vL_p	Saturated liquid volume
# vV_T	Saturated vapour volume
# vL_T	Saturated liquid volume
# v_pT	Specific volume as a function of pressure and temperature.
# v_ph	Specific volume as a function of pressure and enthalpy
# v_ps	Specific volume as a function of pressure and entropy.
#
# Density
# rhoV_p	Saturated vapour density
# rhoL_p	Saturated liquid density
# rhoV_T	Saturated vapour density
# rhoL_T	Saturated liquid density
# rho_pT	Density as a function of pressure and temperature.
# rho_ph	Density as a function of pressure and enthalpy
# rho_ps	Density as a function of pressure and entropy.
#
# Specific entropy
# sV_p	Saturated vapour entropy
# sL_p	Saturated liquid entropy
# sV_T	Saturated vapour entropy
# sL_T	Saturated liquid entropy
# s_pT	Specific entropy as a function of pressure and temperature (Returns saturated vapour Enthalpy if mixture.)
# s_ph	Specific entropy as a function of pressure and enthalpy
#
# Specific internal energy
# uV_p	Saturated vapour internal energy
# uL_p	Saturated liquid internal energy
# uV_T	Saturated vapour internal energy
# uL_T	Saturated liquid internal energy
# u_pT	Specific internal energy as a function of pressure and temperature.
# u_ph	Specific internal energy as a function of pressure and enthalpy
# u_ps	Specific internal energy as a function of pressure and entropy.
#
# Specific isobaric heat capacity
# CpV_p	Saturated vapour heat capacity
# CpL_p	Saturated liquid heat capacity
# CpV_T	Saturated vapour heat capacity
# CpL_T	Saturated liquid heat capacity
# Cp_pT	Specific isobaric heat capacity as a function of pressure and temperature.
# Cp_ph	Specific isobaric heat capacity as a function of pressure and enthalpy
# Cp_ps	Specific isobaric heat capacity as a function of pressure and entropy.
#
# Specific isochoric heat capacity
# CvV_p	Saturated vapour isochoric heat capacity
# CvL_p	Saturated liquid isochoric heat capacity
# CvV_T	Saturated vapour isochoric heat capacity
# CvL_T	Saturated liquid isochoric heat capacity
# Cv_pT	Specific isochoric heat capacity as a function of pressure and temperature.
# Cv_ph	Specific isochoric heat capacity as a function of pressure and enthalpy
# Cv_ps	Specific isochoric heat capacity as a function of pressure and entropy.
#
# Speed of sound
# wV_p	Saturated vapour speed of sound
# wL_p	Saturated liquid speed of sound
# wV_T	Saturated vapour speed of sound
# wL_T	Saturated liquid speed of sound
# w_pT	Speed of sound as a function of pressure and temperature.
# w_ph	Speed of sound as a function of pressure and enthalpy
# w_ps	Speed of sound as a function of pressure and entropy.
#
# Viscosity
# Viscosity is not part of IAPWS Steam IF97. Equations from
# "Revised Release on the IAPWS Formulation 1985 for the Viscosity of Ordinary Water Substance", 2003 are used.
# Viscosity in the mixed region (4) is interpolated according to the density. This is not true since it will
# be two phases
# my_pT	Viscosity as a function of pressure and temperature.
# my_ph	Viscosity as a function of pressure and enthalpy
# my_ps	Viscosity as a function of pressure and entropy.
#
# Thermal Conductivity
# Revised release on the IAPWS Formulation 1985 for the Thermal Conductivity of ordinary water substance (IAPWS 1998)
# tcL_p	Saturated vapour thermal conductivity
# tcV_p	Saturated liquid thermal conductivity
# tcL_T	Saturated vapour thermal conductivity
# tcV_T	Saturated liquid thermal conductivity
# tc_pT	Thermal conductivity as a function of pressure and temperature.
# tc_ph	Thermal conductivity as a function of pressure and enthalpy
# tc_hs	Thermal conductivity as a function of enthalpy and entropy
#
# Surface tension
# st_T	Surface tension for two phase water/steam as a function of T
# st_p	Surface tension for two phase water/steam as a function of T
# Vapour fraction
# x_ph	Vapour fraction as a function of pressure and enthalpy
# x_ps	Vapour fraction as a function of pressure and entropy.
#
# Vapour volume fraction
# vx_ph	Vapour volume fraction as a function of pressure and enthalpy
# vx_ps	Vapour volume fraction as a function of pressure and entropy.


@jit(float64(float64), cache=True, nopython=True)
def tsat_p(p):
    if 0.000611657 < p < 22.06395:
        return t4_p(p)
    else:
        return math.nan


@jit(float64(float64), cache=True, nopython=True)
def tsat_s(s):
    if -0.0001545495919 < s < 9.155759395:
        ps = p4_s(s)
        return t4_p(ps)
    else:
        return math.nan


@jit(float64(float64, float64), cache=True, nopython=True)
def t_ph(p, h):
    region = region_ph(p, h)
    out = 1.0
    if region == 1:
        out = (t1_ph(p, h))
    elif region == 2:
        out = (t2_ph(p, h))
    elif region == 3:
        out = (t3_ph(p, h))
    elif region == 4:
        out = (t4_p(p))
    elif region == 5:
        out = (t5_ph(p, h))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def t_ps(p, s):
    region = region_ps(p, s)
    if region == 1:
        out = (t1_ps(p, s))
    elif region == 2:
        out = (t2_ps(p, s))
    elif region == 3:
        out = (t3_ps(p, s))
    elif region == 4:
        out = (t4_p(p))
    elif region == 5:
        out = (t5_ps(p, s))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def t_hs(h, s):
    region = region_hs(h, s)
    if region == 1:
        p1 = p1_hs(h, s)
        out = t1_ph(p1, h)
    elif region == 2:
        p2 = p2_hs(h, s)
        out = t2_ph(p2, h)
    elif region == 3:
        p3 = p3_hs(h, s)
        out = t3_ph(p3, h)
    elif region == 4:
        out = t4_hs(h, s)
    elif region == 5:
        # error('functions of hs is not available in region 5')
        # raise NotImplementedError
        out = math.nan
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def psat_t(t):
    # out = None
    if 647.096 > t > 273.15:
        out = p4_t(t)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def psat_s(s):
    # out = None
    if -0.0001545495919 < s < 9.155759395:
        out = p4_s(s)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def p_hs(h, s):
    # out = None
    region = region_hs(h, s)
    if region == 1:
        out = (p1_hs(h, s))
    elif region == 2:
        out = (p2_hs(h, s))
    elif region == 3:
        out = (p3_hs(h, s))
    elif region == 4:
        tsat = t4_hs(h, s)
        out = (p4_t(tsat))
    elif region == 5:
        # error('functions of hs is not available in region 5');
        # raise NotImplementedError
        out = math.nan
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.4 Enthalpy (h)

@jit(float64(float64), cache=True, nopython=True)
def hv_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        out = h4v_p(p)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def hl_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        out = h4l_p(p)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def hv_t(t):
    # out = None
    if 273.15 < t < 647.096:
        p = p4_t(t)
        out = h4v_p(p)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def hl_t(t):
    if 273.15 < t < 647.096:
        p = p4_t(t)
        out = h4l_p(p)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def h_pt(p, t):
    region = region_pt(p, t)
    if region == 1:
        out = (h1_pt(p, t))
    elif region == 2:
        out = (h2_pt(p, t))
    elif region == 3:
        out = (h3_pt(p, t))
    elif region == 4:
        out = math.nan
    elif region == 5:
        out = (h5_pt(p, t))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def h_ps(p, s):
    # out = None
    region = region_ps(p, s)
    if region == 1:
        out = h1_pt(p, t1_ps(p, s))
    elif region == 2:
        out = (h2_pt(p, t2_ps(p, s)))
    elif region == 3:
        out = (h3_rhot(1 / v3_ps(p, s), t3_ps(p, s)))
    elif region == 4:
        xs = x4_ps(p, s)
        out = (xs * h4v_p(p) + (1 - xs) * h4l_p(p))
    elif region == 5:
        out = (h5_pt(p, t5_ps(p, s)))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def h_px(p, x):
    if x > 1 or x < 0 or p >= 22.064:
        return math.nan

    hl = h4l_p(p)
    hv = h4v_p(p)
    return hl + x * (hv - hl)


@jit(float64(float64, float64), cache=True, nopython=True)
def h_prho(p, rho):
    region = region_prho(p, rho)
    if region == 1:
        out = h1_pt(p, t1_prho(p, rho))
    elif region == 2:
        out = h2_pt(p, t2_prho(p, rho))
    elif region == 3:
        out = h3_rhot(rho, t3_prho(p, rho))
    elif region == 4:
        if p < 16.529:
            vv = v2_pt(p, t4_p(p))
            vl = v1_pt(p, t4_p(p))
        else:
            vv = v3_ph(p, h4v_p(p))
            vl = v3_ph(p, h4l_p(p))

        hv = h4v_p(p)
        hl = h4l_p(p)
        x = (1 / rho - vl) / (vv - vl)
        return (1 - x) * hl + x * hv
    elif region == 5:
        out = h5_pt(p, t5_prho(p, rho))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def h_tx(t, x):
    if x > 1 or x < 0 or t >= 647.096:
        return math.nan

    p = p4_t(t)
    hl = h4l_p(p)
    hv = h4v_p(p)
    return hl + x * (hv - hl)


# %***********************************************************************************************************
# %*1.5 Specific Volume (v)
@jit(float64(float64), cache=True, nopython=True)
def vv_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = v2_pt(p, t4_p(p))
        else:
            out = v3_ph(p, h4v_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def rhov_p(p):
    out = vv_p(p)
    return 1 / out


@jit(float64(float64), cache=True, nopython=True)
def vl_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = (v1_pt(p, t4_p(p)))
        else:
            out = (v3_ph(p, h4l_p(p)))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def rhol_p(p):
    out = vl_p(p)
    return 1 / out


@jit(float64(float64), cache=True, nopython=True)
def vv_t(t):
    # out = None
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = v2_pt(p4_t(t), t)
        else:
            out = v3_ph(p4_t(t), h4v_p(p4_t(t)))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def rhov_t(t):
    out = vv_t(t)
    return 1 / out


@jit(float64(float64), cache=True, nopython=True)
def vl_t(t):
    # out = None
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = v1_pt(p4_t(t), t)
        else:
            out = v3_ph(p4_t(t), h4l_p(p4_t(t)))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def rhol_t(t):
    out = vl_t(t)
    return 1 / out


@jit(float64(float64, float64), cache=True, nopython=True)
def v_pt(p, t):
    # out = None
    region = region_pt(p, t)
    if region == 1:
        out = v1_pt(p, t)
    elif region == 2:
        out = v2_pt(p, t)
    elif region == 3:
        out = v3_ph(p, h3_pt(p, t))
    elif region == 4:
        out = math.nan
    elif region == 5:
        out = v5_pt(p, t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def rho_pt(p, t):
    out = v_pt(p, t)
    return 1 / out


@jit(float64(float64, float64), cache=True, nopython=True)
def v_ph(p, h):
    region = region_ph(p, h)
    # out = None
    if region == 1:
        out = (v1_pt(p, t1_ph(p, h)))
    elif region == 2:
        out = (v2_pt(p, t2_ph(p, h)))
    elif region == 3:
        out = (v3_ph(p, h))
    elif region == 4:
        xs = x4_ph(p, h)
        if p < 16.529:
            v4v = v2_pt(p, t4_p(p))
            v4l = v1_pt(p, t4_p(p))
        else:
            v4v = v3_ph(p, h4v_p(p))
            v4l = v3_ph(p, h4l_p(p))

        out = (xs * v4v + (1 - xs) * v4l)
    elif region == 5:
        ts = t5_ph(p, h)
        out = v5_pt(p, ts)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def rho_ph(p, h):
    out = v_ph(p, h)
    return 1 / out


@jit(float64(float64, float64), cache=True, nopython=True)
def v_ps(p, s):
    region = region_ps(p, s)
    # out = None

    if region == 1:
        out = v1_pt(p, t1_ps(p, s))
    elif region == 2:
        out = v2_pt(p, t2_ps(p, s))
    elif region == 3:
        out = v3_ps(p, s)
    elif region == 4:
        xs = x4_ps(p, s)
        if p < 16.529:
            v4v = v2_pt(p, t4_p(p))
            v4l = v1_pt(p, t4_p(p))
        else:
            v4v = v3_ph(p, h4v_p(p))
            v4l = v3_ph(p, h4l_p(p))

        out = (xs * v4v + (1 - xs) * v4l)
    elif region == 5:
        ts = t5_ps(p, s)
        out = (v5_pt(p, ts))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def rho_ps(p, s):
    out = v_ps(p, s)
    return 1 / out


# %***********************************************************************************************************
# %*1.6 Density (rho)
# % Density is calculated as 1/v. Se section 1.5 Volume
# %***********************************************************************************************************
# %*1.7 Specific entropy (s)
@jit(float64(float64), cache=True, nopython=True)
def sv_p(p):
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = s2_pt(p, t4_p(p))
        else:
            out = s3_rhot(1 / (v3_ph(p, h4v_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def sl_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = s1_pt(p, t4_p(p))
        else:
            out = s3_rhot(1 / (v3_ph(p, h4l_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def sv_t(t):
    # out = None
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = s2_pt(p4_t(t), t)
        else:
            out = s3_rhot(1 / (v3_ph(p4_t(t), h4v_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def sl_t(t):
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = s1_pt(p4_t(t), t)
        else:
            out = s3_rhot(1 / (v3_ph(p4_t(t), h4l_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def s_pt(p, t):
    # out = None
    region = region_pt(p, t)
    if region == 1:
        out = s1_pt(p, t)
    elif region == 2:
        out = s2_pt(p, t)
    elif region == 3:
        hs = h3_pt(p, t)
        rhos = 1 / v3_ph(p, hs)
        out = s3_rhot(rhos, t)
    elif region == 4:
        out = math.nan
    elif region == 5:
        out = s5_pt(p, t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def s_ph(p, h):
    # out = None
    region = region_ph(p, h)
    if region == 1:
        t = t1_ph(p, h)
        out = (s1_pt(p, t))
    elif region == 2:
        t = t2_ph(p, h)
        out = (s2_pt(p, t))
    elif region == 3:
        rhos = 1 / v3_ph(p, h)
        ts = t3_ph(p, h)
        out = (s3_rhot(rhos, ts))
    elif region == 4:
        ts = t4_p(p)
        xs = x4_ph(p, h)
        if p < 16.529:
            s4v = s2_pt(p, ts)
            s4l = s1_pt(p, ts)
        else:
            v4v = v3_ph(p, h4v_p(p))
            s4v = s3_rhot(1 / v4v, ts)
            v4l = v3_ph(p, h4l_p(p))
            s4l = s3_rhot(1 / v4l, ts)

        out = (xs * s4v + (1 - xs) * s4l)
    elif region == 5:
        t = t5_ph(p, h)
        out = s5_pt(p, t)
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.8 Specific internal energy (u)
@jit(float64(float64), cache=True, nopython=True)
def uv_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = (u2_pt(p, t4_p(p)))
        else:
            out = (u3_rhot(1 / (v3_ph(p, h4v_p(p))), t4_p(p)))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def ul_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = u1_pt(p, t4_p(p))
        else:
            out = u3_rhot(1 / (v3_ph(p, h4l_p(p))), t4_p(p))

    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def uv_t(t):
    # out = None
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = u2_pt(p4_t(t), t)
        else:
            out = u3_rhot(1 / (v3_ph(p4_t(t), h4v_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def ul_t(t):
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = (u1_pt(p4_t(t), t))
        else:
            out = (u3_rhot(1 / (v3_ph(p4_t(t), h4l_p(p4_t(t)))), t))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def u_pt(p, t):
    region = region_pt(p, t)
    if region == 1:
        out = u1_pt(p, t)
    elif region == 2:
        out = u2_pt(p, t)
    elif region == 3:
        hs = h3_pt(p, t)
        rhos = 1 / v3_ph(p, hs)
        out = u3_rhot(rhos, t)
    elif region == 4:
        out = math.nan
    elif region == 5:
        out = u5_pt(p, t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def u_ph(p, h):
    region = region_ph(p, h)
    if region == 1:
        ts = t1_ph(p, h)
        out = u1_pt(p, ts)
    elif region == 2:
        ts = t2_ph(p, h)
        out = u2_pt(p, ts)
    elif region == 3:
        rhos = 1 / v3_ph(p, h)
        ts = t3_ph(p, h)
        out = u3_rhot(rhos, ts)
    elif region == 4:
        ts = t4_p(p)
        xs = x4_ph(p, h)
        if p < 16.529:
            u4v = u2_pt(p, ts)
            u4l = u1_pt(p, ts)
        else:
            v4v = v3_ph(p, h4v_p(p))
            u4v = u3_rhot(1 / v4v, ts)
            v4l = v3_ph(p, h4l_p(p))
            u4l = u3_rhot(1 / v4l, ts)

        out = (xs * u4v + (1 - xs) * u4l)
    elif region == 5:
        ts = t5_ph(p, h)
        out = u5_pt(p, ts)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def u_ps(p, s):
    region = region_ps(p, s)
    if region == 1:
        ts = t1_ps(p, s)
        out = (u1_pt(p, ts))
    elif region == 2:
        ts = t2_ps(p, s)
        out = (u2_pt(p, ts))
    elif region == 3:
        rhos = 1 / v3_ps(p, s)
        ts = t3_ps(p, s)
        out = (u3_rhot(rhos, ts))
    elif region == 4:
        if p < 16.529:
            ulp = u1_pt(p, t4_p(p))
            uvp = u2_pt(p, t4_p(p))
        else:
            ulp = u3_rhot(1 / (v3_ph(p, h4l_p(p))), t4_p(p))
            uvp = u3_rhot(1 / (v3_ph(p, h4v_p(p))), t4_p(p))

        xs = x4_ps(p, s)
        out = (xs * uvp + (1 - xs) * ulp)
    elif region == 5:
        ts = t5_ps(p, s)
        out = (u5_pt(p, ts))
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.9 Specific isobaric heat capacity (Cp)
@jit(float64(float64), cache=True, nopython=True)
def cpv_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = cp2_pt(p, t4_p(p))
        else:
            out = cp3_rhot(1 / (v3_ph(p, h4v_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def cpl_p(p):
    # out = None
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = cp1_pt(p, t4_p(p))
        else:
            out = cp3_rhot(1 / (v3_ph(p, h4l_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def cpv_t(t):
    # out = None
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = cp2_pt(p4_t(t), t)
        else:
            out = cp3_rhot(1 / (v3_ph(p4_t(t), h4v_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def cpl_t(t):
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = cp1_pt(p4_t(t), t)
        else:
            out = cp3_rhot(1 / (v3_ph(p4_t(t), h4l_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def cp_pt(p, t):
    region = region_pt(p, t)
    if region == 1:
        out = cp1_pt(p, t)
    elif region == 2:
        out = cp2_pt(p, t)
    elif region == 3:
        hs = h3_pt(p, t)
        rhos = 1 / v3_ph(p, hs)
        out = cp3_rhot(rhos, t)
    elif region == 4:
        out = math.nan
    elif region == 5:
        out = cp5_pt(p, t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def cp_ph(p, h):
    # out = None
    region = region_ph(p, h)
    if region == 1:
        ts = t1_ph(p, h)
        out = cp1_pt(p, ts)
    elif region == 2:
        ts = t2_ph(p, h)
        out = cp2_pt(p, ts)
    elif region == 3:
        rhos = 1 / v3_ph(p, h)
        ts = t3_ph(p, h)
        out = cp3_rhot(rhos, ts)
    elif region == 4:
        out = math.nan
    elif region == 5:
        ts = t5_ph(p, h)
        out = cp5_pt(p, ts)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def cp_ps(p, s):
    # out = None
    region = region_ps(p, s)
    if region == 1:
        ts = t1_ps(p, s)
        out = cp1_pt(p, ts)
    elif region == 2:
        ts = t2_ps(p, s)
        out = cp2_pt(p, ts)
    elif region == 3:
        rhos = 1 / v3_ps(p, s)
        ts = t3_ps(p, s)
        out = cp3_rhot(rhos, ts)
    elif region == 4:
        out = math.nan
    elif region == 5:
        ts = t5_ps(p, s)
        out = cp5_pt(p, ts)
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.10 Specific isochoric heat capacity (Cv)
@jit(float64(float64), cache=True, nopython=True)
def cvv_p(p):
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = cv2_pt(p, t4_p(p))
        else:
            out = cv3_rhot(1 / (v3_ph(p, h4v_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def cvl_p(p):
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = cv1_pt(p, t4_p(p))
        else:
            out = cv3_rhot(1 / (v3_ph(p, h4l_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def cvv_t(t):
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = cv2_pt(p4_t(t), t)
        else:
            out = cv3_rhot(1 / (v3_ph(p4_t(t), h4v_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def cvl_t(t):
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = cv1_pt(p4_t(t), t)
        else:
            out = cv3_rhot(1 / (v3_ph(p4_t(t), h4l_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def cv_pt(p, t):
    region = region_pt(p, t)
    # out = None
    if region == 1:
        out = cv1_pt(p, t)
    elif region == 2:
        out = cv2_pt(p, t)
    elif region == 3:
        hs = h3_pt(p, t)
        rhos = 1 / v3_ph(p, hs)
        out = cv3_rhot(rhos, t)
    elif region == 4:
        out = math.nan
    elif region == 5:
        out = cv5_pt(p, t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def cv_ph(p, h):
    region = region_ph(p, h)
    # out = None

    if region == 1:
        ts = t1_ph(p, h)
        out = cv1_pt(p, ts)
    elif region == 2:
        ts = t2_ph(p, h)
        out = cv2_pt(p, ts)
    elif region == 3:
        rhos = 1 / v3_ph(p, h)
        ts = t3_ph(p, h)
        out = cv3_rhot(rhos, ts)
    elif region == 4:
        out = math.nan
    elif region == 5:
        ts = t5_ph(p, h)
        out = cv5_pt(p, ts)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def cv_ps(p, s):
    region = region_ps(p, s)
    # out = None
    if region == 1:
        ts = t1_ps(p, s)
        out = cv1_pt(p, ts)
    elif region == 2:
        ts = t2_ps(p, s)
        out = cv2_pt(p, ts)
    elif region == 3:
        rhos = 1 / v3_ps(p, s)
        ts = t3_ps(p, s)
        out = cv3_rhot(rhos, ts)
    elif region == 4:
        out = math.nan  # (xs * CvVp + (1 - xs) * CvLp) / Cv_scale - Cv_offset
    elif region == 5:
        ts = t5_ps(p, s)
        out = cv5_pt(p, ts)
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.11 Speed of sound

@jit(float64(float64), cache=True, nopython=True)
def wv_p(p):
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = w2_pt(p, t4_p(p))
        else:
            out = w3_rhot(1 / (v3_ph(p, h4v_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def wl_p(p):
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            out = w1_pt(p, t4_p(p))
        else:
            out = w3_rhot(1 / (v3_ph(p, h4l_p(p))), t4_p(p))
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def wv_t(t):
    # out = None
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = w2_pt(p4_t(t), t)
        else:
            out = w3_rhot(1 / (v3_ph(p4_t(t), h4v_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64), cache=True, nopython=True)
def wl_t(t):
    # out = None
    if 273.15 < t < 647.096:
        if t <= 623.15:
            out = w1_pt(p4_t(t), t)
        else:
            out = w3_rhot(1 / (v3_ph(p4_t(t), h4l_p(p4_t(t)))), t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def w_pt(p, t):
    region = region_pt(p, t)
    if region == 1:
        out = w1_pt(p, t)
    elif region == 2:
        out = w2_pt(p, t)
    elif region == 3:
        hs = h3_pt(p, t)
        rhos = 1 / v3_ph(p, hs)
        out = w3_rhot(rhos, t)
    elif region == 4:
        out = math.nan
    elif region == 5:
        out = w5_pt(p, t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def w_ph(p, h):
    region = region_ph(p, h)
    if region == 1:
        ts = t1_ph(p, h)
        out = w1_pt(p, ts)
    elif region == 2:
        ts = t2_ph(p, h)
        out = w2_pt(p, ts)
    elif region == 3:
        rhos = 1 / v3_ph(p, h)
        ts = t3_ph(p, h)
        out = w3_rhot(rhos, ts)
    elif region == 4:
        out = math.nan
    elif region == 5:
        ts = t5_ph(p, h)
        out = w5_pt(p, ts)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def w_ps(p, s):
    region = region_ps(p, s)
    if region == 1:
        ts = t1_ps(p, s)
        out = w1_pt(p, ts)
    elif region == 2:
        ts = t2_ps(p, s)
        out = w2_pt(p, ts)
    elif region == 3:
        rhos = 1 / v3_ps(p, s)
        ts = t3_ps(p, s)
        out = w3_rhot(rhos, ts)
    elif region == 4:
        out = math.nan  # %(xs * wVp + (1 - xs) * wLp) / w_scale - w_offset
    elif region == 5:
        ts = t5_ps(p, s)
        out = w5_pt(p, ts)
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.12 Viscosity

@jit(float64(float64, float64), cache=True, nopython=True)
def my_pt(p, t):
    region = region_pt(p, t)
    # out = None
    if region == 4:
        out = math.nan
    elif region == 1 or region == 2 or region == 3 or region == 5:
        out = my_all_regions_pt(p, t)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def my_ph(p, h):
    region = region_ph(p, h)
    # out = None
    if region == 1 or region == 2 or region == 3 or region == 5:
        out = my_all_regions_ph(p, h)
    elif region == 4:
        out = math.nan
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def my_ps(p, s):
    h = h_ps(p, s)
    out = my_ph(p, h)
    return out


# %***********************************************************************************************************
# %*1.14 Kappa
# %***********************************************************************************************************

# %***********************************************************************************************************
# %*1.15 Surface tension
@jit(float64(float64), cache=True, nopython=True)
def st_t(t):
    out = surface_tension_t(t)
    return out


@jit(float64(float64), cache=True, nopython=True)
def st_p(p):
    t = tsat_p(p)
    out = surface_tension_t(t)
    return out


# %***********************************************************************************************************
# %*1.16 Thermal conductivity
@jit(float64(float64), cache=True, nopython=True)
def tcl_p(p):
    t = tsat_p(p)
    v = vl_p(p)
    rho = 1 / v
    out = tc_ptrho(p, t, rho)
    return out


@jit(float64(float64), cache=True, nopython=True)
def tcv_p(ps):
    t = tsat_p(ps)
    v = vv_p(ps)
    p = ps
    rho = 1 / v
    out = tc_ptrho(p, t, rho)
    return out


@jit(float64(float64), cache=True, nopython=True)
def tcl_t(ts):
    p = psat_t(ts)
    v = vl_t(ts)
    t = ts
    rho = 1 / v
    out = tc_ptrho(p, t, rho)
    return out


@jit(float64(float64), cache=True, nopython=True)
def tcv_t(ts):
    p = psat_t(ts)
    v = vv_t(ts)
    t = ts
    rho = 1 / v
    out = tc_ptrho(p, t, rho)
    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def tc_pt(ps, ts):
    v = v_pt(ps, ts)
    p = ps
    t = ts
    rho = 1 / v
    out = tc_ptrho(p, t, rho)
    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def tc_ph(ps, hs):
    v = v_ph(ps, hs)
    t = t_ph(ps, hs)
    p = ps
    rho = 1 / v
    out = tc_ptrho(p, t, rho)
    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def tc_hs(hs, s):
    p = p_hs(hs, s)
    ps = p
    v = v_ph(ps, hs)
    t = t_ph(ps, hs)
    rho = 1 / v
    out = tc_ptrho(p, t, rho)
    return out


# %***********************************************************************************************************
# %*1.17 Vapour fraction

@jit(float64(float64, float64), cache=True, nopython=True)
def x_ph(p, h):
    if 0.000611657 < p < 22.06395:
        out = x4_ph(p, h)
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def x_ps(p, s):
    if 0.000611657 < p < 22.06395:
        out = x4_ps(p, s)
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.18 Vapour Volume Fraction
@jit(float64(float64, float64), cache=True, nopython=True)
def vx_ph(p, h):
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            vl = v1_pt(p, t4_p(p))
            vv = v2_pt(p, t4_p(p))
        else:
            vl = v3_ph(p, h4l_p(p))
            vv = v3_ph(p, h4v_p(p))

        xs = x4_ph(p, h)
        out = (xs * vv / (xs * vv + (1 - xs) * vl))
    else:
        out = math.nan

    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def vx_ps(p, s):
    if 0.000611657 < p < 22.06395:
        if p < 16.529:
            vl = v1_pt(p, t4_p(p))
            vv = v2_pt(p, t4_p(p))
        else:
            vl = v3_ph(p, h4l_p(p))
            vv = v3_ph(p, h4v_p(p))

        xs = x4_ps(p, s)
        out = (xs * vv / (xs * vv + (1 - xs) * vl))
    else:
        out = math.nan

    return out


# %***********************************************************************************************************
# %*1.13 Prandtl
@jit(float64(float64, float64), cache=True, nopython=True)
def pr_pt(p, t):
    cp = cp_pt(p, t)
    my = my_pt(p, t)
    tc = tc_pt(p, t)
    out = cp * 1000 * my / tc
    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def pr_ph(p, h):
    cp = cp_ph(p, h)
    my = my_ph(p, h)
    tc = tc_ph(p, h)
    out = cp * 1000 * my / tc
    return out


@jit(float64(float64, float64), cache=True, nopython=True)
def p_hrho(h, rho):
    # %Not valid for water or super critical since water rho
    # does not change very much with p.
    # %Uses iteration to find p.
    high_bound = 100
    low_bound = 0.000611657
    ps = 10
    rhos = 1 / v_ph(ps, h)
    while abs(rho - rhos) > 0.0000001:
        rhos = 1 / v_ph(ps, h)
        if rhos >= rho:
            high_bound = ps
        else:
            low_bound = ps

        ps = (low_bound + high_bound) / 2

    return ps


def self_test(show=False):
    def dummy(*arg, **kwargs):
        pass

    echo = dummy
    if show:
        echo = print

    echo('REGION 1')
    echo('TABLE 5')
    echo(v1_pt(3, 300), h1_pt(3, 300), u1_pt(3, 300), s1_pt(3, 300), cp1_pt(3, 300), w1_pt(3, 300))
    echo(v1_pt(80, 300), h1_pt(80, 300), u1_pt(80, 300), s1_pt(80, 300), cp1_pt(80, 300), w1_pt(80, 300))
    echo(v1_pt(3, 500), h1_pt(3, 500), u1_pt(3, 500), s1_pt(3, 500), cp1_pt(3, 500), w1_pt(3, 500))

    echo('TABLE 7')
    echo(t1_ph(3, 500))
    echo(t1_ph(80, 500))
    echo(t1_ph(80, 1500))

    echo('TABLE 9')
    echo(t1_ps(3, 0.5))
    echo(t1_ps(80, 0.5))
    echo(t1_ps(80, 3.0))

    echo('TABLE 3')
    echo(p1_hs(0.001, 0.0))
    echo(p1_hs(90, 0.0))
    echo(p1_hs(1500, 3.4))

    echo('REGION 2')
    echo('TABLE 2')
    echo(v2_pt(0.0035, 300), h2_pt(0.0035, 300), u2_pt(0.0035, 300), s2_pt(0.0035, 300), cp2_pt(0.0035, 300),
         w2_pt(0.0035, 300))
    echo(v2_pt(0.0035, 700), h2_pt(0.0035, 700), u2_pt(0.0035, 700), s2_pt(0.0035, 700), cp2_pt(0.0035, 700),
         w2_pt(0.0035, 700))
    echo(v2_pt(30, 700), h2_pt(30, 700), u2_pt(30, 700), s2_pt(30, 700), cp2_pt(30, 700), w2_pt(30, 700))

    echo('TABLE 24')
    echo(t2_ph(0.001, 3000))
    echo(t2_ph(3.0, 3000))
    echo(t2_ph(3.0, 4000))
    echo(t2_ph(5.0, 3500))
    echo(t2_ph(5.0, 4000))
    echo(t2_ph(25.0, 3500))
    echo(t2_ph(40.0, 2700))
    echo(t2_ph(60.0, 2700))
    echo(t2_ph(60.0, 3200))

    echo('TABLE 29')
    echo(t2_ps(0.1, 7.5))
    echo(t2_ps(0.1, 8))
    echo(t2_ps(2.5, 8))
    echo(t2_ps(8.0, 6))
    echo(t2_ps(8.0, 7.5))
    echo(t2_ps(90.0, 6))
    echo(t2_ps(20.0, 5.75))
    echo(t2_ps(80.0, 5.25))
    echo(t2_ps(80.0, 5.75))

    echo('TABLE 3')
    echo(p2_hs(2800, 6.5))
    echo(p2_hs(2800, 9.5))
    echo(p2_hs(4100, 9.5))
    echo(p2_hs(2800, 6))
    echo(p2_hs(3600, 6))
    echo(p2_hs(3600, 7))
    echo(p2_hs(2800, 5.1))
    echo(p2_hs(2800, 5.8))
    echo(p2_hs(3400, 5.8))

    echo('REGION 3')
    echo('TABLE 33')
    echo(p3_rhot(500, 650), h3_rhot(500, 650), u3_rhot(500, 650), s3_rhot(500, 650), cp3_rhot(500, 650),
         w3_rhot(500, 650))
    echo(p3_rhot(200, 650), h3_rhot(200, 650), u3_rhot(200, 650), s3_rhot(200, 650), cp3_rhot(200, 650),
         w3_rhot(200, 650))
    echo(p3_rhot(500, 750), h3_rhot(500, 750), u3_rhot(500, 750), s3_rhot(500, 750), cp3_rhot(500, 750),
         w3_rhot(500, 750))

    echo('t3_ph')
    echo(t3_ph(20.0, 1700))
    echo(t3_ph(50.0, 2000))
    echo(t3_ph(100.0, 2100))
    echo(t3_ph(20.0, 2500))
    echo(t3_ph(50.0, 2400))
    echo(t3_ph(100.0, 2700))

    echo('v3_ph')
    echo(v3_ph(20.0, 1700))
    echo(v3_ph(50.0, 2000))
    echo(v3_ph(100.0, 2100))
    echo(v3_ph(20.0, 2500))
    echo(v3_ph(50.0, 2400))
    echo(v3_ph(100.0, 2700))

    echo('t3_ps')
    echo(t3_ps(20.0, 3.7))
    echo(t3_ps(50.0, 3.5))
    echo(t3_ps(100.0, 4))
    echo(t3_ps(20.0, 5))
    echo(t3_ps(50.0, 4.5))
    echo(t3_ps(100.0, 5))

    echo('v3_ps')
    echo(v3_ps(20.0, 3.7))
    echo(v3_ps(50.0, 3.5))
    echo(v3_ps(100.0, 4))
    echo(v3_ps(20.0, 5))
    echo(v3_ps(50.0, 4.5))
    echo(v3_ps(100.0, 5))

    echo('p3_hs')
    echo(p3_hs(1700, 3.8))
    echo(p3_hs(2000, 4.2))
    echo(p3_hs(2100, 4.3))
    echo(p3_hs(2500, 5.1))
    echo(p3_hs(2400, 4.7))
    echo(p3_hs(2700, 5))

    echo('h3_pt')
    echo(h3_pt(25.583702, 650))
    echo(h3_pt(22.293064, 650))
    echo(h3_pt(78.309564, 750))

    echo('REGION 4')
    echo('TABLE 35')
    echo(p4_t(300))
    echo(p4_t(500))
    echo(p4_t(600))

    echo('t4_p')
    echo(t4_p(0.1))
    echo(t4_p(1.0))
    echo(t4_p(10.0))

    echo('h4_s')
    echo(h4_s(1))
    echo(h4_s(2))
    echo(h4_s(3))
    echo(h4_s(3.8))
    echo(h4_s(4))
    echo(h4_s(4.2))
    echo(h4_s(7))
    echo(h4_s(8))
    echo(h4_s(9))
    echo(h4_s(5.5))
    echo(h4_s(5))
    echo(h4_s(4.5))

    echo('REGION 5')
    echo('TABLE 42')
    echo(v5_pt(0.5, 1500), h5_pt(0.5, 1500), u5_pt(0.5, 1500), s5_pt(0.5, 1500), cp5_pt(0.5, 1500), w5_pt(0.5, 1500))
    echo(v5_pt(8.0, 1500), h5_pt(8.0, 1500), u5_pt(8.0, 1500), s5_pt(8.0, 1500), cp5_pt(8.0, 1500), w5_pt(8.0, 1500))
    echo(v5_pt(8.0, 2000), h5_pt(8.0, 2000), u5_pt(8.0, 2000), s5_pt(8.0, 2000), cp5_pt(8.0, 2000), w5_pt(8.0, 2000))

    echo('t5_ph')
    echo(t5_ph(0.5, 5219.76331549428))
    echo(t5_ph(8, 5206.09634477373))
    echo(t5_ph(8, 6583.80290533381))

    echo('t5_ps')
    echo(t5_ps(0.5, 9.65408430982588))
    echo(t5_ps(8, 8.36546724495503))
    echo(t5_ps(8, 9.15671044273249))

    echo('TESTING CALLS')
    echo(tsat_p(0.1) - 273.15)
    echo(t_ph(0.1, 100) - 273.15)
    echo(t_ps(0.1, 1) - 273.15)
    echo(t_hs(100, 0.2) - 273.15)
    echo(psat_t(100 + 273.15) * 10)
    echo(p_hs(84, 0.296) * 10)

    echo(hv_p(1 * 0.1))
    echo(hl_p(1 * 0.1))
    echo(hv_t(100 + 273.15))
    echo(hl_t(100 + 273.15))
    echo(h_pt(1 * 0.1, 20 + 273.15))
    echo(h_ps(1 * 0.1, 1))
    echo(h_px(1 * 0.1, 0.5))
    echo(h_prho(1 * 0.1, 2))
    echo(h_tx(100 + 273.15, 0.5))

    echo(vv_p(1 * 0.1))
    echo(vl_p(1 * 0.1))
    echo(vv_t(100 + 273.15))
    echo(vl_t(100 + 273.15))
    echo(v_pt(1 * 0.1, 100 + 273.15))
    echo(v_ph(1 * 0.1, 1000))
    echo(v_ps(1 * 0.1, 5))

    echo(rhov_p(1 * 0.1))
    echo(rhol_p(1 * 0.1))
    echo(rhov_t(100 + 273.15))
    echo(rhol_t(100 + 273.15))
    echo(rho_pt(1 * 0.1, 100 + 273.15))
    echo(rho_ph(1 * 0.1, 1000))
    echo(rho_ps(1 * 0.1, 1))

    echo(sv_p(0.006117 * 0.1))
    echo(sl_p(0.0061171 * 0.1))
    echo(sv_t(0.0001 + 273.15))
    echo(sl_t(100 + 273.15))
    echo(s_pt(1 * 0.1, 20 + 273.15))
    echo(s_ph(1 * 0.1, 84.01181117))

    echo(uv_p(1 * 0.1))
    echo(ul_p(1 * 0.1))
    echo(uv_t(100 + 273.15))
    echo(ul_t(100 + 273.15))
    echo(u_pt(1 * 0.1, 100 + 273.15))
    echo(u_ph(1 * 0.1, 1000))
    echo(u_ps(1 * 0.1, 1))

    echo(cpv_p(1 * 0.1))
    echo(cpl_p(1 * 0.1))
    echo(cpv_t(100 + 273.15))
    echo(cpl_t(100 + 273.15))
    echo(cp_pt(1 * 0.1, 100 + 273.15))
    echo(cp_ph(1 * 0.1, 200))
    echo(cp_ps(1 * 0.1, 1))

    echo(cvv_p(1 * 0.1))
    echo(cvl_p(1 * 0.1))
    echo(cvv_t(100 + 273.15))
    echo(cvl_t(100 + 273.15))
    echo(cv_pt(1 * 0.1, 100 + 273.15))
    echo(cv_ph(1 * 0.1, 200))
    echo(cv_ps(1 * 0.1, 1))

    echo(wv_p(1 * 0.1))
    echo(wl_p(1 * 0.1))
    echo(wv_t(100 + 273.15))
    echo(wl_t(100 + 273.15))
    echo(w_pt(1 * 0.1, 100 + 273.15))
    echo(w_ph(1 * 0.1, 200))
    echo(w_ps(1 * 0.1, 1))

    echo(my_pt(1 * 0.1, 100 + 273.15))
    echo(my_ph(1 * 0.1, 100))
    echo(my_ps(1 * 0.1, 1))

    echo(tcl_p(1 * 0.1))
    echo(tcv_p(1 * 0.1))
    echo(tcl_t(25 + 273.15))
    echo(tcv_t(25 + 273.15))
    echo(tc_pt(1 * 0.1, 25 + 273.15))
    echo(tc_ph(1 * 0.1, 100))
    echo(tc_hs(100, 0.34))

    echo(st_t(100 + 273.15))
    echo(st_p(1 * 0.1))

    echo(x_ph(1 * 0.1, 1000))
    echo(x_ps(1 * 0.1, 4))

    echo(vx_ph(1 * 0.1, 418))
    echo(vx_ps(1 * 0.1, 4))




def self_test_calc_only():
    v1_pt(3, 300), h1_pt(3, 300), u1_pt(3, 300), s1_pt(3, 300), cp1_pt(3, 300), w1_pt(3, 300)
    v1_pt(80, 300), h1_pt(80, 300), u1_pt(80, 300), s1_pt(80, 300), cp1_pt(80, 300), w1_pt(80, 300)
    v1_pt(3, 500), h1_pt(3, 500), u1_pt(3, 500), s1_pt(3, 500), cp1_pt(3, 500), w1_pt(3, 500)

    t1_ph(3, 500)
    t1_ph(80, 500)
    t1_ph(80, 1500)

    t1_ps(3, 0.5)
    t1_ps(80, 0.5)
    t1_ps(80, 3.0)

    p1_hs(0.001, 0.0)
    p1_hs(90, 0.0)
    p1_hs(1500, 3.4)

    v2_pt(0.0035, 300), h2_pt(0.0035, 300), u2_pt(0.0035, 300), s2_pt(0.0035, 300), cp2_pt(0.0035, 300), w2_pt(0.0035,
                                                                                                               300)
    v2_pt(0.0035, 700), h2_pt(0.0035, 700), u2_pt(0.0035, 700), s2_pt(0.0035, 700), cp2_pt(0.0035, 700), w2_pt(0.0035,
                                                                                                               700)
    v2_pt(30, 700), h2_pt(30, 700), u2_pt(30, 700), s2_pt(30, 700), cp2_pt(30, 700), w2_pt(30, 700)

    t2_ph(0.001, 3000)
    t2_ph(3.0, 3000)
    t2_ph(3.0, 4000)
    t2_ph(5.0, 3500)
    t2_ph(5.0, 4000)
    t2_ph(25.0, 3500)
    t2_ph(40.0, 2700)
    t2_ph(60.0, 2700)
    t2_ph(60.0, 3200)

    t2_ps(0.1, 7.5)
    t2_ps(0.1, 8)
    t2_ps(2.5, 8)
    t2_ps(8.0, 6)
    t2_ps(8.0, 7.5)
    t2_ps(90.0, 6)
    t2_ps(20.0, 5.75)
    t2_ps(80.0, 5.25)
    t2_ps(80.0, 5.75)

    p2_hs(2800, 6.5)
    p2_hs(2800, 9.5)
    p2_hs(4100, 9.5)
    p2_hs(2800, 6)
    p2_hs(3600, 6)
    p2_hs(3600, 7)
    p2_hs(2800, 5.1)
    p2_hs(2800, 5.8)
    p2_hs(3400, 5.8)

    p3_rhot(500, 650), h3_rhot(500, 650), u3_rhot(500, 650), s3_rhot(500, 650), cp3_rhot(500, 650), w3_rhot(500, 650)
    p3_rhot(200, 650), h3_rhot(200, 650), u3_rhot(200, 650), s3_rhot(200, 650), cp3_rhot(200, 650), w3_rhot(200, 650)
    p3_rhot(500, 750), h3_rhot(500, 750), u3_rhot(500, 750), s3_rhot(500, 750), cp3_rhot(500, 750), w3_rhot(500, 750)

    t3_ph(20.0, 1700)
    t3_ph(50.0, 2000)
    t3_ph(100.0, 2100)
    t3_ph(20.0, 2500)
    t3_ph(50.0, 2400)
    t3_ph(100.0, 2700)

    v3_ph(20.0, 1700)
    v3_ph(50.0, 2000)
    v3_ph(100.0, 2100)
    v3_ph(20.0, 2500)
    v3_ph(50.0, 2400)
    v3_ph(100.0, 2700)

    t3_ps(20.0, 3.7)
    t3_ps(50.0, 3.5)
    t3_ps(100.0, 4)
    t3_ps(20.0, 5)
    t3_ps(50.0, 4.5)
    t3_ps(100.0, 5)

    v3_ps(20.0, 3.7)
    v3_ps(50.0, 3.5)
    v3_ps(100.0, 4)
    v3_ps(20.0, 5)
    v3_ps(50.0, 4.5)
    v3_ps(100.0, 5)

    p3_hs(1700, 3.8)
    p3_hs(2000, 4.2)
    p3_hs(2100, 4.3)
    p3_hs(2500, 5.1)
    p3_hs(2400, 4.7)
    p3_hs(2700, 5)

    h3_pt(25.583702, 650)
    h3_pt(22.293064, 650)
    h3_pt(78.309564, 750)

    p4_t(300)
    p4_t(500)
    p4_t(600)

    t4_p(0.1)
    t4_p(1.0)
    t4_p(10.0)

    h4_s(1)
    h4_s(2)
    h4_s(3)
    h4_s(3.8)
    h4_s(4)
    h4_s(4.2)
    h4_s(7)
    h4_s(8)
    h4_s(9)
    h4_s(5.5)
    h4_s(5)
    h4_s(4.5)

    v5_pt(0.5, 1500), h5_pt(0.5, 1500), u5_pt(0.5, 1500), s5_pt(0.5, 1500), cp5_pt(0.5, 1500), w5_pt(0.5, 1500)
    v5_pt(8.0, 1500), h5_pt(8.0, 1500), u5_pt(8.0, 1500), s5_pt(8.0, 1500), cp5_pt(8.0, 1500), w5_pt(8.0, 1500)
    v5_pt(8.0, 2000), h5_pt(8.0, 2000), u5_pt(8.0, 2000), s5_pt(8.0, 2000), cp5_pt(8.0, 2000), w5_pt(8.0, 2000)

    t5_ph(0.5, 5219.76331549428)
    t5_ph(8, 5206.09634477373)
    t5_ph(8, 6583.80290533381)

    t5_ps(0.5, 9.65408430982588)
    t5_ps(8, 8.36546724495503)
    t5_ps(8, 9.15671044273249)

    tsat_p(0.1) - 273.15
    t_ph(0.1, 100) - 273.15
    t_ps(0.1, 1) - 273.15
    t_hs(100, 0.2) - 273.15
    psat_t(100 + 273.15) * 10
    p_hs(84, 0.296) * 10

    hv_p(1 * 0.1)
    hl_p(1 * 0.1)
    hv_t(100 + 273.15)
    hl_t(100 + 273.15)
    h_pt(1 * 0.1, 20 + 273.15)
    h_ps(1 * 0.1, 1)
    h_px(1 * 0.1, 0.5)
    h_prho(1 * 0.1, 2)
    h_tx(100 + 273.15, 0.5)

    vv_p(1 * 0.1)
    vl_p(1 * 0.1)
    vv_t(100 + 273.15)
    vl_t(100 + 273.15)
    v_pt(1 * 0.1, 100 + 273.15)
    v_ph(1 * 0.1, 1000)
    v_ps(1 * 0.1, 5)

    rhov_p(1 * 0.1)
    rhol_p(1 * 0.1)
    rhov_t(100 + 273.15)
    rhol_t(100 + 273.15)
    rho_pt(1 * 0.1, 100 + 273.15)
    rho_ph(1 * 0.1, 1000)
    rho_ps(1 * 0.1, 1)

    sv_p(0.006117 * 0.1)
    sl_p(0.0061171 * 0.1)
    sv_t(0.0001 + 273.15)
    sl_t(100 + 273.15)
    s_pt(1 * 0.1, 20 + 273.15)
    s_ph(1 * 0.1, 84.01181117)

    uv_p(1 * 0.1)
    ul_p(1 * 0.1)
    uv_t(100 + 273.15)
    ul_t(100 + 273.15)
    u_pt(1 * 0.1, 100 + 273.15)
    u_ph(1 * 0.1, 1000)
    u_ps(1 * 0.1, 1)

    cpv_p(1 * 0.1)
    cpl_p(1 * 0.1)
    cpv_t(100 + 273.15)
    cpl_t(100 + 273.15)
    cp_pt(1 * 0.1, 100 + 273.15)
    cp_ph(1 * 0.1, 200)
    cp_ps(1 * 0.1, 1)

    cvv_p(1 * 0.1)
    cvl_p(1 * 0.1)
    cvv_t(100 + 273.15)
    cvl_t(100 + 273.15)
    cv_pt(1 * 0.1, 100 + 273.15)
    cv_ph(1 * 0.1, 200)
    cv_ps(1 * 0.1, 1)

    wv_p(1 * 0.1)
    wl_p(1 * 0.1)
    wv_t(100 + 273.15)
    wl_t(100 + 273.15)
    w_pt(1 * 0.1, 100 + 273.15)
    w_ph(1 * 0.1, 200)
    w_ps(1 * 0.1, 1)

    my_pt(1 * 0.1, 100 + 273.15)
    my_ph(1 * 0.1, 100)
    my_ps(1 * 0.1, 1)

    tcl_p(1 * 0.1)
    tcv_p(1 * 0.1)
    tcl_t(25 + 273.15)
    tcv_t(25 + 273.15)
    tc_pt(1 * 0.1, 25 + 273.15)
    tc_ph(1 * 0.1, 100)
    tc_hs(100, 0.34)

    st_t(100 + 273.15)
    st_p(1 * 0.1)

    x_ph(1 * 0.1, 1000)
    x_ps(1 * 0.1, 4)

    vx_ph(1 * 0.1, 418)
    vx_ps(1 * 0.1, 4)


def self_test_profile():
    x = [self_test_calc_only() for i in range(1000)]



# self_test(show=True)
